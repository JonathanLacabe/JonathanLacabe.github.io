<!doctype html>
<html>
  <head>
  	<meta charset="UTF-8" />
    <title>Stream Ciphers (Symmetric Cryptography) Summary</title>
    <link href="/style.css" rel="stylesheet" />
    <link rel="icon" href="/favicon.ico">
  </head>
<body>
      <div class="wrapper">
      
      <header class="site" style="color: green; font-family: arial; line-height: 0em;">                                                                                                                      
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/javascript">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [["$", "$"], ["\\(", "\\)"]],
    },
    "HTML-CSS": {
      scale: 100, //Scale math to match surrounding text
    },
    displayAlign: "left", //Align equations to the left
  });
</script>

<script>
document.addEventListener("DOMContentLoaded", function (){
    //Loop through Rule containers
    let ruleContainers = document.querySelectorAll(".rules");
    ruleContainers.forEach(container =>{
        //Get starting Rule number, use 1 if unspecified.
        let startNumber = parseInt(container.getAttribute("data-start")) || 1;
        let rules = container.querySelectorAll(".rule");
        rules.forEach((rule, index) =>{
            let ruleNumber = startNumber + index;

            //Assign dynamic id to Rule container -> anchor link targets it
            rule.id = "Rule" + ruleNumber;

            //Update all elements displaying Rule #
            let numberElements = rule.querySelectorAll(".rule-number");
            numberElements.forEach(el => {
                el.textContent = ruleNumber;
            });

            //Update the href to target correct id, while preserving '#'.
            let ruleLink = rule.querySelector("a");
            if(ruleLink){
                ruleLink.href = "#Rule" + ruleNumber;
            }
        });
    });
});
</script>

<img src="/_other/logos/Symmetric_Encryption.png" width=36%><!--ALSO SPRACH ZARATHUSTRA.-->
<hr>
      	<span><em>Art by Shoaib Pasha.</em></span><hr>
      </header>

      <div class="inner">
	<nav>
		<div class="cont">
		  <a href="/index.html">Home</a><br>
		  <a href="/sitemap.txt">Sitemap</a><br>
		  <hr>
		  <a href="/Physics/physics.html">Physics</a><br>
		  <a href="/math/mathematics.html">Math</a><br>
		  <a href="/cryptography/cryptography.html">Crypto.</a><br>
		  <a href="/engineering/electric.html">Electric</a><br><!--It looks better as "Electric", considering Nuclear is without a period as well-->
		  <a href="/astronomy/astronomy.html">Astronomy</a><br>
		  <a href="/engineering/aeronautics.html">Aero.</a><br>
		  <a href="/engineering/nuclear.html">Nuclear</a><br>
		  <hr><!--Internal Pages-->
		  <a href="/information/recentchanges.txt">Recent Changes</a><br>
		  <a href="/information/color.html">Color Code</a><br>
		  <a href="/information/art.html">Logos</a><br>
		  <a href="/information/about.html#FAQ">FAQ</a><br><!--Will link to a section within the about page-->
		  <a href="/information/about.html">About</a><br>
		  <hr><!--All Mirrors-->
		  <a href="https://hkproject.org/">HKProject</a><br>
		  <a href="https://github.com/JonathanLacabe/JonathanLacabe.github.io">GitHub</a><br>
		  <a href="https://humanknowledge.neocities.org/">Neocities</a><br>
		</div>
	</nav>
	
	<div class="content">
	  <header class="articleHeader">
	    <h2>Summary of Stream Ciphers (Symmetric Cryptography)</h2>
	    <!--<h3><em>Theory > Application.</em></h3>-->
	  </header>
	  <hr>
	  <article>
	    <p>These are my complete notes for Stream Ciphers in Symmetric Cryptography. <br><br>I color-coded my notes according to their meaning - for a complete reference for each type of note, see <a href="/information/color.html">here</a> (also available in the sidebar). All of the knowledge present in these notes has been filtered through my personal explanations for them, the result of my attempts to understand and study them from my classes and online courses. In the unlikely event there are any egregious errors, contact me at <a href="mailto:jdlacabe@gmail.com">jdlacabe@gmail.com</a>.</p>
	  </article>
	  
	  <article><center><strong><h3>Table Of Contents</h3></strong></center></article>
	  
      <div class="toc-container">
        <div class="toc-column">
          <a href="#StreamIntro">III.I Intro to Stream Ciphers.</a>
        </div>
        <div class="toc-column">
          <a href="#LFSR">III.III L.F.S.R.'s.</a>
        </div>
      </div>
      
      <div class="toc-container">
        <div class="toc-column">
          <a href="#RNG">III.II Random Number Generation.</a>
        </div>
        
        <div class="toc-column">
          <a href="#AltSecureStream">III.IV Alt. Secure Stream Ciphers.</a>
        </div>
      </div>
      
      <div class="rules" data-start="24">
	  
	  <header class="articleHeader"><hr>
	    <h2><span class="mw-headline" id="StreamCiphers">III. Stream Ciphers.</span></h2>
	    <h3><span class="mw-headline" id="StreamIntro">III.I Introduction to Stream Ciphers.</span></h3>
	  </header>
	  <article>
	  
	  <strong><a href="#Fig3"><span class="mw-headline" id="Fig3">#</span></a> Fig. 3. - Symmetric Cryptography Hierarchy:</strong><br>
      <div class="image-environment" role="img" aria-labelledby="image-alt-1"> <a href="/cryptography/img/cryptog.png"><img src="/cryptography/img/cryptog.png" alt="A Classification hierarchy of Symmetric Cryptography. There are two major branches of Symmetric Cryptography, Block Ciphers and Stream Ciphers. See Subsection I.I for the full tree, and see Rule 7 for Cryptanalysis." width=58%/></a></div>
	    <span class="tiny"><em>A Classification hierarchy of Symmetric Cryptography. There are two major branches of Symmetric Cryptography, Block Ciphers and Stream Ciphers. See Subsection I.I for the full tree, and see Rule 7 for Cryptanalysis.</em></span><br><br><br><br>
	  
	  
      <div class="rule"><strong>
          <a href="#Rule"><span class="hash">#</span></a> 
          <font color="red">C. Rule <span class="rule-number"></span>.</font>
      </strong> <strong>Modular 2 Operations</strong>:<br><br>
        In cryptography, when considering all of the mathematical operations commonly applied in primitives and ciphers, the <strong>modular 2 operation</strong> carries with it a set of properties and a reputation that makes it unique even within modular arithmetic.<Br><br>
        
        <strong>Mod 2 addition and subtraction are the same operation</strong>. Multiplication complicates things, but in all instances where the mod 2 function is limited to addition or subtraction, the results will be identical no matter which operation is applied.<br><br>
        
        <!--I purposely wrote this section with the sortf profound, "when there comes a time in human history" sorta vibe to it. Earl Sweatshirt - Off Top on repeat.-->
      
        With the smallest possible modulus that allows room for variation in the remainder<!--(since mod 1 produces straight 0s)-->, mod 2 operations are by and large the most popular application of modular arithmetic in cryptography. This is because their restriction of all numbers to be either 0s or 1s (by the very nature of a <em>modular operation</em>, see Rule 11) successfully emulates binary representation, making them extremely useful for bit-based computation (and in particular ciphers that intake streams of data, like stream ciphers (see Rule 25)).<br><br><!--Intake is a verb now. Jonathanization of the english language. 'atleast' and 'eachother' are also words now. -->
        <!--it has assumed a life almost detached from modular arithmetic-->
        
        The modular 2 operation is used so often, it has its own symbol in cryptographic diagrams: <strong>a circle with a cross</strong>. See Rule 25 for an example. In electrical engineering, the mod 2 function is known as the <strong>XOR gate</strong>, a type of binary gate (see E.E. [[[[[), further showcasing the broader importance of modular 2 operations in science as a whole. <br><br>
        
    	  Note that the listed properties do <STRONG>NOT</STRONG> extend to the modulus of any other number - only for two. See the Vigenère Cipher (see Rule 21), which works akin to a stream cipher, for proof using mod 26 (hint: the addition and subtraction operations produce different values).
    	  
    	 </div><br><br><br>
      	 
      	 
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Stream Ciphers</strong><br><br>

      <strong><u>Mathematical Definition</u></strong>:<br><br>
      
      <em>
      (x<sub>i</sub>, y<sub>i</sub>, s<sub>i</sub>) ∈ <strong>ℤ</strong><sub>2</sub><br><br>
      <strong>Encryption</strong>: <strong>e<sub>s<sub>i</sub></sub>(x<sub>i</sub>) ≡ (x<sub>i</sub> + s<sub>i</sub>) mod 2</strong><br><br>
      <strong>Decryption</strong>: <strong>d<sub>s<sub>i</sub></sub>(y<sub>i</sub>) ≡ (y<sub>i</sub> + s<sub>i</sub>) mod 2</strong>
      
      </em><br><br><br>
      
      <strong>x<sub>i</sub></strong> = The Plaintext bit at index i.<br>
      <strong>y<sub>i</sub></strong> = The Ciphertext bit at index i.<br>
      <strong>s<sub>i</sub></strong> = The <strong>"Keystream"</strong> at index i, equivalent to 'k' (as in past ciphers). Here, it is the Key (at index i) fed into the encryption and decryption functions.<br>
      <strong><strong>ℤ</strong><sub>2</sub></strong> = A ring of the first 2 integers: {0, 1}. See Subsection II.III for an explanation of rings.<br>
      <strong>e<sub>s<sub>i</sub></sub>(x<sub>i</sub>)</strong> = Encryption function, a mathematical formula that converts each x bit into a y bit.<br>
      <strong>d<sub>s<sub>i</sub></sub>(y<sub>i</sub>)</strong> = Decryption function, a mathematical formula that converts each y bit into an x bit.<br>
      <strong>mod 2</strong> = The modulus/remainder operator with respect to 2. Numbers can only be 0 or 1 in this reality - see Rule 24 for a full treatise.
      
      <br><br><br>


      <strong><u>Explanation:</u></strong><br><br>
      A cipher that encrypts bits individually, processing one bit after another in a sequence. This is opposed to a Block Cipher (see Section IV), which takes in large numbers of bits all at once.<br><br>
      
      
      Using the modular 2 operation (see Rule 24), the encryption and decryption functions of the basic stream cipher can be depicted as shown in Fig. 4.<br><br>

        The central complexity of the Stream Cipher is the generation of the "Keystream", e.g. the stream of bits with which the plaintext is encrypted. This generation must be performed through <em>Random Numbers</em> - see Rule 26.<br><br>
        
        If the keybit (s<sub>i</sub>) is zero, then the plaintext bit will pass through unchanged, but if the keybit is 1, then the plaintext bit will flip (like binary). Thus, if the keystream (by divine intervention) is straight 0's, then the plaintext will go unencrypted. 
        
        <!--Most beautiful 90 seconds in Cryptography:
        https://youtu.be/AELVJL0axRs?list=PL2jrku-ebl3H50FiEPr4erSJiJHURM9BX&t=1520
        
        the Mozart Piano Concerto #21 Andante of Cryptography lecture segments
        
        -->
	      </div><br><br><br>
	      
	      
	      
	      <strong><a href="#Fig4"><span class="mw-headline" id="Fig4">#</span></a> Fig. 4. - Practical Stream Ciphers:</strong><br>
          <div class="image-environment" role="img" aria-labelledby="image-alt-1"> <a href="/cryptography/img/PracticalStream.png"><img src="/cryptography/img/PracticalStream.png" alt="A diagram of how all practical stream ciphers should function, with the modular 2 addition highlighted and the keystream generator (which varies from cipher to cipher) displayed." width=79%/></a></div>
    	    <span class="tiny"><em>A diagram of how all <em>practical</em> stream ciphers (abiding by the encryption and decryption functions defined in Rule 25) function, with the modular 2 addition highlighted and the keystream generator (which varies from cipher to cipher) displayed. Note that the key distribution is not depicted.</em></span><br><br><br><br>
	      
	  
	  
	      <strong><a href="#KeyStreamDef"><span class="mw-headline" id="KeyStreamDef">#</span></a> <font color="#006400">Keystream</font></strong>: A <u><em>stream</em></u> of characters that is combined with the plaintext to produce the ciphertext in a Stream Cipher, or, in the case of asynchronous stream ciphers, combined with a previous ciphertext to produce a new ciphertext.<br><br>

        The keystream is derived from the <u><em>key</em></u> and the <u><em>seed</em></u>. Generally, the keystream is denoted as "s<sub>i</sub>", while the seed itself is s<sub>0</sub>, the initial position/keybit of the stream from which all recursive stream ciphers evolve from in their encryption functions. Inherently, the number of possible seeds is the same as the <strong>keyspace</strong>, since the number of seeds dictates how many keys there can be.<br><br>
        
        The creation of a keystream (both key and seed) involves random number generators, which are detailed in Subsection III.II. The seed, for example, may be created using an actual True Random Number Generator (see Rule 26), while the rest of the key will be deterministically generated <em>from</em> that seed using a PRNG (also Rule 26).<br><!--I was just like, what the hell do I do with all of these parentheticals that are ruining the flow of the thing? asterixize them, of course!-->
        
        <!--**at least all ciphers that use a PRNG algorithm, like the LCG (see Rule 28).-->
        <br><br><br>
	  
	  
    	  <strong><a href="#SynchronousStreamDef"><span class="mw-headline" id="SynchronousStreamDef">#</span></a> <font color="#006400">Synchronous Stream Cipher</font></strong>: A Stream Cipher in which the keystream depends solely on the key, generated independently of the plaintext or ciphertext. Examples include Salsa20 & ChaCha.
        <br><br><br>
        
    	  
    	  <strong><a href="#AsynchronousStreamDef"><span class="mw-headline" id="AsynchronousStreamDef">#</span></a> <font color="#006400">Asynchronous Stream Cipher</font></strong>: A Stream Cipher in which the keystream depends on the ciphertext in addition to the key - the key generation is reliant on previous ciphertext, making it a risky operation. An example is the Cipher Feedback (CFB) mode, described in Rule [[[.
        <br><br><br>
        
	  
	      
	    </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="RNG">III.II Random Number Generation.</span></h3>
	    </header>
	    <article>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Random Number Generators (RNG)</strong>:<br><br> The means with which a system can generate random numbers, for the purposes of constructing/filling a keystream with random bits, are split into three main mechanisms:<br><br>

        <ol>
          <li> <strong>True Random Number Generators (TRNGs)</strong>: "True" random numbers stem from random physical processes that cannot be reproduced. Such <em>natural</em> sources of entropy include flipping a coin, rolling a die, thermal noise, mouse movement, and keystroke timing.<br><br>
          
          Hardware and cryptographic systems have tried a lot of different techniques over the years to create a TRNG by analyzing/recording internal characteristics of the computer. Most modern CPU's have a TRNG within a TPM  (trusted platform module) on the motherboard.<br><br>
          
          An example of a cipher that <em>completely</em> uses TRNGs (not just for one element like the seed, but for the <u><em>entire keystream</em></u>) is the One Time Pad, detailed in Rule 27.
          
          </li><br><br>
          
          
          <li> <strong>Pseudo Random Number Generators (PRNGs)</strong>: An RNG system that is random, but reproducable. Because PRNG's are computed, they are inherently deterministic processes. Since they are deterministic, Alice and Bob can generate the same keystream independently of one another, only needing to know the initial "seed", which is like the key for the key (see the "Keystream" definition).<br><br>
          
          Often, PRNG's are computed with the following function:<br><br>
          
          <strong> s<sub>i+1</sub> = f(s<sub>i</sub>)</strong><br><br>
          
          <strong>s<sub>0</sub></strong> = The initial seed value, which may be an actual TRNG.<br>
          <strong>f(s<sub>i</sub>)</strong> = The 'randomizer' function, which performs whatever upon the seed
          in order to computationally randomize it.<br><br>
          
          This recursive generation is the form taken by the Linear Congruential Generator, an example of a cryptosystem utilizing a PRNG (see Rule 28). <br><br>
          The rand() function in C is a PRNG and uses a seed of 12345, with the following function as the randomizer: <br>S<sub>i+1</sub> = ((1103515245 × s<sub>i</sub>) + 12345) mod 2³¹.
          </li><br><br>
          
          
          <li><strong>Cryptographically Secure Pseudorandom Number Generators (CSPRNGs/CPRNGs)</strong>: PRNG's that have an additional property: the numbers must be <strong><u>unpredictable</u></strong>.<br><br>
          
          Given n output keybits (s<sub>i</sub>, s<sub>i+1</sub>, ..., s<sub>i+(n-1)</sub>), it is computationally infeasible to construct s<sub>i+n</sub>.<br><br>
          
          While in most applications (read: the world outside cryptography), PRNG systems are perfectly fine and suited to create 'random' numbers for whatever purpose, they form very unsecure cryptosystems due to their inherently deterministic nature, and thus in Cryptography, the additional property of unpredictability is required. An example of a commonly-used CPRNG in the real world is the [[[.
          
          
          </li>
        
        </ol>
        </div><br><br>


        <strong><a href="#UnconditionalSecurityDef"><span class="mw-headline" id="UnconditionalSecurityDef">#</span></a> <font color="#006400">Unconditional Security</font></strong>: A cipher is "unconditionally secure" (or "information-theoretically secure") if it cannot be broken even with <u>infinite</u> computing resources. <br><br>
        
        Even if a key is 2^1000 bits, it would not be considered "unconditionally secure", because 2^1000 computers (a patently <u>not</u> infinite amount of computers) would be able to break the key in one second. This is despite the fact that such levels of computing power will never be realized in human history.<br><br> 
        Thus, though there are very many ciphers that are "practically" secure (forming the backbone of our modern cybersecurity systems), they are not unconditionally secure.
        <br><br><br>
        
        
        <strong><a href="#ComputationalSecurityDef"><span class="mw-headline" id="ComputationalSecurityDef">#</span></a> <font color="#006400">Computational Security</font></strong>: A cryptosystem is computationally secure if the best known algorithm for breaking it requires at least t operations, where 't' is some ridiculous number far beyond the reach of modern brute-force computational abilities.
        <br><br><br>

	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>One Time Pad (OTP)</strong><br><br>
          The <strong>One Time Pad</strong> (also referred to as the "<strong>Vernam cipher</strong>") is an example of a TRNG-based cryptosystem. It is <em>the</em> unconditionally secure, totally unbreakable, perfect encryption algorithm. The OTP is a stream cipher with the following properties:<br><br>
          1) The Keystream bits s<sub>i</sub> must originate from a True Random Number Generator (a 'TRNG', see Rule [[[, 1.).<br><br>
          2) Each Keystream bit must be used only once.<br><br>
          
          Knowledge of the Keystream must be exclusively limited to the involved parties, of course. At the end of the data transfer, the party that received the data must destroy the key so that it cannot be used by another party to decrypt the message after the fact. This is the same reason why reusing keys is extremely risky and nullifies the security benefits of the OTP.<br><br>
          
          The security of cryptosystem draws from the fact that, without knowledge of the keystream, even a brute-force attack would be futile, because any two text strings are equally as probable to be a particular word in the plaintext: if a four letter word were to be encrypted, it is equally probable for it to be "when", "stop", or "abcd".<br><br>
          
          There is one fundamental drawback of the OTP, however, that prevents its universal application: since keystream bits cannot be reused, <strong>the key has to be as long as the plaintext</strong>. A 400MB file, 8 bits to the byte, would entail a 3.2GB key. As such, the One Time Pad is not the be-all-end-all of Cryptography (at least in terms of application), and other types of CPRNGS are still relevant.
          </div><br><br><br><br>
          
          
          
          
          
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Linear Congruential Generator (LCG)</strong>:<br><br>

          <strong><u>Mathematical Definition</u></strong>:<br><br>
          
            <em>
            (A, B, i, S<sub>i</sub>) ∈ <strong>ℤ</strong><sub>m</sub><br>
            i > 0<br>
            Key K = (A, B)<Br><br>
            
            <strong>S<sub>i + 1</sub> ≡ ((A × S<sub>i</sub>) + B) mod m</strong>
            
            </em><br><br><br>
            
            <strong>S<sub>0</sub></strong> = The initial seed value, which may have been created using a TRNG. Of course, it is not depicted in the equation as the equation only refers to i > 0. The seed value is exactly ⌈log<sub>2</sub> m⌉ bits long, explained below. <br>
            
            <strong>S<sub>i</sub></strong> = The Keystream at index i, where i > 0. It is exactly ⌈log<sub>2</sub> m⌉ bits long, explained below. <br>
            
            <strong>S<sub>i + 1</sub></strong> = The following value in the keystream, which is recursively calculated using the value of the previous bit in the keystream (along with the key). It is exactly ⌈log<sub>2</sub> m⌉ bits long, explained below.<br>
            
            <strong>A</strong> = The multiplied value of the key. It is exactly ⌈log<sub>2</sub> m⌉ bits long, explained below. <br>
            
            <strong>B</strong> = The "shift parameter" value of the key, only used for the addition operation. It is exactly ⌈log<sub>2</sub> m⌉ bits long, explained below.<br>
            
            <strong><strong>ℤ</strong><sub>m</sub></strong> = A ring of m integers. See Subsection II.III for an explanation of rings.<br>
            
            <strong>mod m</strong> = The modulus/remainder operator, which represents the usage of modular arithmetic, with all numbers represented by their remainder with respect to m.
            <br><br><br>
          
          
          <strong><u>Explanation:</u></strong><br><br>
          
          The LCG is a PRNG-based keystream generator, using the attributes of the key and the seed as its base components. It is an example of a non-cryptographically secure PRNG, the 2nd type of RNG detailed in Rule 26. This makes it more practical a system than the One Time Pad (see Rule [[[), but much easier to break (see Rule 29). The keystream is deterministically created using a recursive function originating at S<sub>0</sub> (the seed), which itself may be created using a TRNG.<br><br>
          
          Of course, separate from the nature of the function/equation itself, note that there are no "Encryption" or "Decryption" functions, because the given equation is merely for composing the keystream (PRNG-style - see Rule 26), while the equation for the Stream <em>Cipher</em> itself remains the same (see Rule 25).<br><br>
          
          The Linear Congruential Generator bears many similarities to the Affine Cipher (Rule 22), in particular how the key is split into multiple parameters (in the case of the LCG, the key used to generate the key<em>stream</em>). However, the <em>length</em> of the parameters greatly differs between the two - while affine ciphers have a set, immutable value for their keyspace, LCG variables derive their length from the modulus itself.<!--I left this sentence as essentially a stream-of-consciousness placeholder to revise later, basically just setting down my ideas so I could polish them later, only to find that it exactly conveyed the point I was trying to get across, in pretty good diction as well. Didn't change a word.--><br><br> 

          	Note that because the modulus represents a set/ring, <strong>ℤ</strong><sub>m</sub>, m qualifies for the set-based bit-length (as detailed in Rule 4). As such, the fact that variables A, B, and S<sub>i</sub> are all ⌈log<sub>2</sub> m⌉ bits long means that <strong>they are as long as the bit-length of the modulus</strong>.<br><br>
          
          Of course, since m is not the keyspace, ⌈log<sub>2</sub> m⌉ is only in reference to a set-based bit-length and not to the key-length. As such, no determination regarding the keyspace of the LCG can be made from ⌈log<sub>2</sub> m⌉, as the equation for finding it using a set-based bit-length (as extensively discussed in Rule 6) specifically requires the <em>key-length</em>. As a bit-based cryptosystem, the LCG <em>does</em> have a key-length (considering it literally generates keys), just not one equal to the bit-length of m.<br><br>
          
          <!--essentially an alternate version of the intro to the previous paragraph. the specification as to how the confusion lies in how the keylength equation is used much more than the set-based bit-length one would have to be worked in to make it functional, but the current one is pretty good anyways:
          Thus, the usage of the equation with m in the usual place of the keyspace does <u>not</u> mean that m is literally the keyspace - this is the fool's conclusion from a cursory glance of the equation.-->
          
           ⌈log<sub>2</sub> m⌉, as the set-based bit-length of m, merely represents the total number of bits required to represent a variable who can have any value between 0 and m-1. To say that A, B, and Si all have a length of ⌈log2 m⌉ bits does not mean that they are all the same value, but just that they all use the same number of bits to represent their values. For example, 00001 and 11111 represent different values in binary, but both have a bit-length of 5.<br><br><br>
          
          The exact reasonings behind <em>why</em> each variable has a bit-length of m, and how things like the key-length and keyspace are calculated, are subject to the design choices of the Linear Congruential Generator itself. As LCGs are PRNGs, understanding the intricacies of these design choices and the exact purpose behind each part of this particular system is irrelevant to learning Cryptography.<br><br>
          
          The decisions made in designing this RNG were not made from a cryptographic standpoint, and thus warrant no in-depth analysis as to aspects like key-length and keyspace size, as the LCG will never be used in a cryptographic context.<br><br>
          
          The mathematics behind the logic for the aforementioned calculations are thoroughly complex and higher-level, and to describe them in great detail would serve no purpose in a cryptography-focused course. Rather, LCGs are useful for their discussion of how PRNGs can be cracked relatively easily (see Rule 29).
          
          <!--FINALLY. I had to add three additional Rules and an entire new Subsection to get to this point. In omnia scientia quaerere-->

          
          
          <!--Apparently, these things have the craziest mathematics behind their functioning, for the key-length and keyspace: LCG constraints often force 𝐴 A to lie in the multiplicative group modulo 𝑚 m, whose size is 𝜑 ( 𝑚 ) φ(m) (Euler’s totient).
          
          They are cryptologically insecure anyways, so whatever, but just note that this things are totally complex. Note what Paar said - there is a huge amount of research and textbooks discussing PRNGs for non-cryptographic purposes, but they are all irrelevant because they are not cryptographically secure.-->



        <!--
        not sure if this unfinished paragraph is true or not, can't find any good information about it, and I am not exerting a huge amount of effort into doing so because of how tangential and non-essential this section is to cryptography as a whole. ergo the "this is irrelevant and complicated mathematics" approach to explaining it.
        
        Note that the keyspace of a linear congruential generator is not calculated in the same fashion as an Affine cipher, however; whereas the affine cipher simply multiplied the components of the key (A & B) together to find the keyspace, the LCG (and all other ciphers that use a key to generate a keystream) is a bit more abstracted in its approach - 
        -->
          
          
          
          
          <!--Easily the hardest rule(s) I have had to write so far in Cryptography, 26 & 27. Took several hours of total concentration and thinking power, requiring the rewriting of portions of past rules and definitions as well.-->
          
          <!--note: Several months after making these Rules, while in the revisal process, it was once again this section that had me go back and edit and create a bunch of earlier Rules in order to better explain the key concepts at play here. The curse of the LCG strikes again.-->
	      </div><br><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>HOW TO CRACK A LINEAR CONGRUENTIAL GENERATOR (LCG):</strong><br><br>

        In order to crack a rudimentary LCG system and discover the full keystream to decrypt the system, the attacker only needs to know three characters of the plaintext that were encrypted (along with all of the ciphertext). Generally, in encrypting a document (such as Microsoft Word or Excel), there will be file or protocol header information at the start (like the version number), which will always be the same initial symbols being encrypted. Therefore, knowledge of the attacker of these plaintext characters, in addition to the ciphertext, can be assumed.<br><br>
        
        With knowledge of the LCG key-stream equation, the attacker would know S<sub>0</sub>, S<sub>1</sub>, and S<sub>2</sub> only. There would thus be three unknowns: A, B, and m. However, the set of commonly used m values is relatively small (see <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use">list</a>), and so iterating through them using brute-force (once A and B have been discovered) would be very simple: simply calculate the associated keystream for each possible m value, then check each keystream using the stream cipher decryption function (see Rule 25) and the known ciphertext, until the correct keystream (and thus m value) is found. Thus, m is considered one of the known variables.<br><br>
        <!--Since modular arithmetic dictates that all integers must be lower than the modulus (the remainder with respect to the modulus), the attacker can easily determine the modulus of a key generation algorithm by just finding the ciphertext keybit with the highest value and then adding one.-->
        
        The attacker only has to create a system of equations-style problem (using the three known plaintext characters and the ciphertext) in order to isolate A and B, respectively.<br><br>
        S<sub>1</sub> ≡ ((A × S<sub>0</sub>) + B) mod m<br>
        S<sub>2</sub> ≡ ((A × S<sub>1</sub>) + B) mod m<br><br>
        
        <strong>A = ((S<sub>1</sub> - S<sub>2</sub>) × (S<sub>0</sub> - S<sub>1</sub>)⁻¹) mod m</strong><br>
        
        <strong>B = (S<sub>1</sub> - (S<sub>0</sub> × (S<sub>1</sub> - S<sub>2</sub>) × (S<sub>0</sub> - S<sub>1</sub>)⁻¹)) mod m</strong><br><br>
        
        After finding A and B, all that would be left to be done is to brute-force m as previously described, and the system would be cracked. The full plaintext would be able to be decoded since every variable of the LCG would be known.
        
        </div><br><br>

	  
	  
	  
	    </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="LFSR">III.III Linear Feedback Shift Registers.</span></h3>
	    </header>
	    <article>
	    
	    
	    <strong><a href="#CSEDef"><span class="mw-headline" id="CSEDef">#</span></a> <font color="#006400">Clocked Storage Element (CSE)</font></strong>: A storage container that captures information at a specific moment in time, storing it until needed. Think of it like a recording device built into the hardware of the computer, and it captures information at the moment a signal is sent to it (updating it to replace whatever information was in it previously).<br><Br><!--completely intuitive explanation that should make sense to anyone without an inkling of e.e. knowledge, I am very proud of this one-->
	    
	    In more explicitly electrical engineering terms, CSE's are part of <em>Clocking Subsystems</em> (see E.E. Rule [[[[[) and respond to Clock signals (see E.E. Rule [[[[[).
        <br><br><br><br>
	    
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> A "<strong>Flip-flop</strong>" is a clocked storage element that stores a single bit. There is an input, an output, and a <strong>Clock Input</strong> that determines whether any inputted bit is to be stored or not.<br><br>

        The general symbology used in diagrams for a flip-flop (in which D is the input & Q is the output) is as follows:<br><br>
  	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/D-flip-flop-basics.png"><img src="/cryptography/img/D-flip-flop-basics.png" alt="A diagram of the basic functions of the flip-flop electrical component. D is the input, Q is the output. Ignore the Q with the line for now. Courtesy of buildcircuitelectronics." width=53%/></a></div>
  	    <span class="tiny"><em>A diagram of the basic functions of the flip-flop electrical component. D is the input, Q is the output. Ignore the Q with the line for now. Courtesy of <a href="https://www.build-electronic-circuits.com/d-flip-flop/">buildcircuitelectronics</a>.</em></span><br><br><br>
  
        And here is a diagram showing how the output relies on clock signals to accept an input change, if any:<br><br>
  	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/D-type_flip-flop_impulse_diagram.png"><img src="/cryptography/img/D-type_flip-flop_impulse_diagram.png" alt="A diagram detailing how the clock signal will influence what data from the input is stored and produced in the output. As shown, the flip-flop will only store the first event captured in the input when the clock signal becomes active, regardless of whether the input changes while the clock signal is still active. Courtesy of Wikipedia." width=60%/></a></div>
  	    <span class="tiny"><em>A diagram detailing how the clock signal will influence what data from the input is stored and produced in the output. As shown, the flip-flop will only store the first event captured in the input when the clock signal becomes active, regardless of whether the input changes while the clock signal is still active. Courtesy of <a href="https://commons.wikimedia.org/wiki/File:D-type_flip-flop_impulse_diagram.png">Wikipedia</a>.</em></span>
  	  
  	    </div><br><br><br>
  	  
  	  
  	    <strong><a href="#ShiftRegisterDef"><span class="mw-headline" id="ShiftRegisterDef">#</span></a> <font color="#006400">Shift Register</font></strong>: A "shift register" is a concatentation of several individual flip-flops, each sending a signal to the next until the final flip-flop, which will produce each bit of the output. It is one half of an LFSR.<br><br>
  
        An example of a shift register, with three flip-flops, with every new value sent receiving a clock signal:<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/ShiftCipherDiag1.png"><img src="/cryptography/img/ShiftCipherDiag1.png" alt="A shift register, complete with three flip-flops, and a starting value of 1-0-0. Data moves over once, and the Diagonal rule (detailed in Rule 31) is used to create the new data values for the latter flip-flops." width=53%/></a></div>
  	    <span class="tiny"><em>A shift register, complete with three flip-flops, and a starting value of 1-0-0. Data moves rightward as the result of a clock signal allowing each flip-flop to take in the data of the flip-flop to its left, and the Diagonal rule (detailed in Rule 31) becomes visible in how the data values effectively move diagonally to the right from their initial position.</em></span>
  	    <!--and then each change is moved over until there are no more changes to be moved.-->
        <br><br><br><br><br>
	      
	      
	      
	      <strong><font color="blue"><a href="#LFSRIntro"><span class="mw-headline" id="LFSRIntro">#</span></a> Introduction to Linear Feedback Shift Registers:</font></strong><br><br>
        There is an inherent relationship between electrical engineering and Cryptography, specifically in how Cryptography developed: in the early days of the development of the Stream Cipher, the goal was to create a 'small' stream cipher, e.g. a stream cipher that could be implemented in hardware without using too much power.<br><br>
        
        Today, all stream ciphers fit one of two categories: ciphers optimized for <strong>software implementation</strong>, and ciphers optimized for <strong>hardware implementation</strong>. A prime example of the latter are "Shift Register-Based Stream Ciphers", in particular shift registers (see definition) with a feedback mechanism, better known as Linear Feedback Shift Registers.
        
        <br><br><br>
	      
	      
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Linear Feedback Shift Registers</strong>:<br><br>

        <strong><u>Mathematical Definition</u></strong>:<br><br>
        
          <em>
          The equation depends on the specific characteristics of the LFSR. Specifically, the number of flip-flops, the number of mod 2 functions, and which flip-flops have mod 2 functions. The following formula applies to all LFSR's and is fully explained/derived in the LFSR Generalization (see Rule 32):<br><br><!--Looking back, I think I handled the problem of the equation well, since the equation is not explicitly explained or detailed in this Rule. For those wanting a refresher on the concept of the LFSR itself, this Rule is good, for those just needing the equation, this Rule is good, and those seeking to comprehend and understand the equation, this note is here to redirect them to the right place.-->
          
          (S<sub>i</sub>, P<sub>j</sub>) ∈ <strong>ℤ</strong><sub>2</sub><br>
          (i, j) ∈ <strong>ℤ</strong><sub>m</sub>
          </em><br><br>
          
          $$S_{m+1} \equiv \left( \sum_{j=0}^{m-1} S_{i+j} \times P_{j} \right) \mod 2$$<br>
          
          <strong>m</strong> = The number of flip-flops in the LFSR. This number determines both the length of the state register and the <em>period</em> (see Rule 34) of the output sequence.<br><br>
          
          <strong>i</strong> = The offset in the shift register, e.g., the number bit of the keystream that is being found. This is why it is ∈ <strong>ℤ</strong><sub>m</sub> - it can go no greater than value m.<br><br>
          
          <strong>j</strong> = The index variable for each individual flip-flop, which have the <em>potential</em> to contribute to the feedback path, as determined by the feedback coefficient.<br><br>
          
          <strong>S<sub>m + 1</sub></strong> = The next output bit into the keystream produced by the LFSR after shifting.<br><br>
          
          <strong>S<sub>i + j</sub></strong> = The bit held by a particular flip-flop j, at a specific offset in the shift register i. This is the value being inputted into the multiplier function from the flip-flop.<br><br>
          
          <strong>P<sub>j</sub></strong> = The feedback coefficient of flip-flop j. Either 0 or 1.<br><br>
          
          <strong>mod 2</strong> = The modulus/remainder operator with respect to 2. Numbers can only be 0 or 1 in this reality.
          <br><br><br>
        
        <!--On God this is the best explanation of each variable. Human Knowledge is the greatest learning resource known to mankind, better than Wikipedia, better than any Alien knowledgebase.-->
  
        <strong><u>Explanation:</u></strong><br><br>
        
        Occasionally referred to as cryptographic "<em>linear recurrences</em>" by various demented individuals, <u><strong>Linear Feedback Shift Registers</strong></u> are yet another PRNG-based keystream generator, and are thus crackable with some effort (see Rule 38).<br><br>
        
        Many ciphers, such as the A51 cipher (see Rule [[[<!--potentially a Rule going over the cipher, or maybe just a detailing later on about how A51 ciphers are standard technology in phones and other technological appliances, if the Rule gets scrapped.-->), consist of multiple LFSRs (in the case of A51, 3), which greatly enhance the security of the cipher and validates the usage of LFSR's for legitimate cryptographic purposes (see Rule [[[<!--potentially some Rule using the lfsr multiple times, but if it is super far ahead, then it would still be good to have a little explanation here detailing how adding more lfsr's increases the security by any means-->).<br><br>
        
        LFSR's incorporate a standard Shift Register with a <strong>feedback mechanism/path</strong>, generating fresh input for the first flip-flop using some output data. This is done by a modular 2 addition function (a.k.a. an XOR gate, detailed in Rule 24), which can be performed between the value from the final flip-flop (by virtue of it being the beginning of the feedback path) and atleast one other in the shift register. Multiple XOR-gates can be added along the feedback path, complicating the structure of the LFSR and enraging Oscar.<br><br>
        
        The mod 2 calculation is first performed in the initial state of the shift register, before the first clock cycle, pre-computing the value that will be used as input for the first flip-flop <u>on</u> the first clock cycle.<br><br>
        
        <strong>Remember:</strong> The feedback mechanism that the outputs take uses a mod2 function, but the actual input into the first flip-flop itself is without any special system - it is directly taking in the given number.<br><br>
  
  
        Very important to notice in the progress of an LFSR is that there will be a distinct pattern that holds in each calculated value (placed below the flip-flops on a diagram), known as the <strong>Diagonal Rule</strong>: each bit value will be translated diagonally to the right, for as many flip-flops as there are to the right, continually. Note this pattern in the diagram below:<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/ShiftCipherDiag2.png"><img src="/cryptography/img/ShiftCipherDiag2.png" alt="A Linear Feedback Shift Register, complete with three flip-flops and a full period of values, which compose one complete keystream." width=75%/></a></div>
  	    <span class="tiny"><em>A Linear Feedback Shift Register, complete with three flip-flops and a full period of values, which compose one complete keystream.</em></span><br><br><br>
  
        The specific mathematical formula of the key produced by the LFSR depicted is:<br> <strong>S<sub>i+3</sub> ≡ (s<sub>i+1</sub> + s<sub>i</sub>) mod 2</strong>.
        
        
        </div><br><br>



        <strong><a href="#FeedbackDef"><span class="mw-headline" id="FeedbackDef">#</span></a> <font color="#006400">Feedback Path/Feedback Mechanism</font></strong>: The path in which all the XOR gates (or other operations) are located, streaming back to the first flip-flop for the new input. This mechanism, when combined with a shift register, forms the basis of an LFSR. 
        <br><br><br>
        
        
        <strong><a href="#LFSRStateDef"><span class="mw-headline" id="LFSRStateDef">#</span></a> <font color="#006400">State (in regard to LFSR's)</font></strong>: The bits of the flip-flops at a particular row-position in the shift register, also referred to as the "<strong>initialization vector</strong>"<!--[[[[[[[explain in detail.--> of the LFSR. Given knowledge of an LFSR state and the XOR-positions/feedback path, every following row of bits can be determined.<br><Br>
        
         Even without knowledge of the XOR positions, by pure knowledge of the first state, almost every flip-flop bit in the following state (except for the first F.F., the recipient of the input of the feedback state) can be determined, as a result of the <u>diagonal rule</u> of LFSRs (see Rule 31).
        <br><br><br>


        <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>LFSR Generalization:</STRONG><br><br> 

        To generalize the LFSR so that a general equation can be applied, several new mathematical operations must be introduced.<br><br>
        
        First, the number of flip-flops in the register can be generalized to an arbitrary 'm' number of times, which is the simplest generalization to be made.<br><br>
        
        It is possible for any of the flip-flops to have an XOR gate, and for there to be as many XOR gates as flip-flops, minus one. Since all of the flip-flops have a chance at being part of the feedback path, a <strong>multiplier function</strong> must be added after each flip-flop, between the path after the flip-flop and any possible XOR gate above on the feedback path. Thus, the multiplier controls the way to the XOR gate, and essentially acts as an on-or-off switch.<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/GeneralizedLFSR.png"><img src="/cryptography/img/GeneralizedLFSR.png" alt="A generalized LFSR, with every possible link between a flip-flop and the feedback path having a multiplier function, serving as the 'switch' determining whether that flip-flop is included as a part of the XOR operation." width=82%/></a></div>
  	    <span class="tiny"><em>A generalized LFSR, with every possible link between a flip-flop and the feedback path having a multiplier function, serving as the 'switch' determining whether that flip-flop is included as a part of the XOR operation.</em></span><br><br><br>
  
        The <strong>multiplier function</strong> works by multiplying the value of the flip-flop (the Input value I) by the internal P-value, which is determined by whether the flip-flop actually has an XOR gate or not (see below). The p-value can only be a binary value: <strong>p<sub>i</sub> ∈ ℤ<sub>2</sub></strong>.<br><br>
        
        The multipliers (labeled P<sub>0</sub> to P<sub>m-1</sub>) have their own values, known as <strong>"feedback coefficients"</strong>. These values are dictated by the "switch", e.g. if there is or isn't a connection to an XOR gate from that flip-flop. Furthermore, there is an input I and output O that travels from the multiplier onto the XOR gate path.<br><br>
        
        If the <strong>switch is closed</strong> (e.g. there IS an XOR gate connected to that flip-flop, and thus a connection to the feedback path), then the p-value will equal 1, since the input is equal to the output: <strong>O = p<sub>i</sub> × I = I</strong>.<br><br>
        
        If the <strong>switch is open</strong> (no XOR gate), then the p-value will equal 0. The output O is equal to 0, and since O = p<sub>i</sub> × I, and I is not necessarily 0, then p<sub>i</sub> must equal 0.<br><br>
        
        For the following formula, you must assume that s<sub>m</sub> is the sum of all of the XOR gates, e.g. the preloaded value that is ready to be inputted into the first flip-flop after the initial state has finished being processed. Thus, the second complete XOR-ing of the values (the second value inputted into the first flip-flop) will be S<sub>m+1</sub>, and so on. The value of the input into the first flip-flop is the result of the summation of all of the possible XOR operations that could be present in the LFSR.<br><br><br>
        
        <em>
        (S<sub>i</sub>, P<sub>j</sub>) ∈ <strong>ℤ</strong><sub>2</sub><br>
        (i, j) ∈ <strong>ℤ</strong><sub>m</sub>
        </em><br>
        
        $$S_{m+1} \equiv \left( \sum_{j=0}^{m-1} S_{i+j} \times P_{j} \right) \mod 2$$<br>
        
        <strong>m</strong> = The number of flip-flops in the LFSR. This number determines both the length of the state register and the <em>period</em> (see Rule 34) of the output sequence.<br><br>
        
        <strong>i</strong> = The offset in the shift register, e.g., the number bit of the keystream that is being found. This is why it is ∈ <strong>ℤ</strong><sub>m</sub> - it can go no greater than value m.<br><br>
        
        <strong>j</strong> = The index variable for each individual flip-flop, which have the <em>potential</em> to contribute to the feedback path, as determined by the feedback coefficient.<br><br>
        
        <strong>S<sub>m + 1</sub></strong> = The next output bit into the keystream produced by the LFSR after shifting.<br><br>
        
        <strong>S<sub>i + j</sub></strong> = The bit held by a particular flip-flop j, at a specific offset in the shift register i. This is the value being inputted into the multiplier function from the flip-flop.<br><br>
        
        <strong>P<sub>j</sub></strong> = The feedback coefficient of flip-flop j. Either 0 or 1.<br><br>
        
        <strong>mod 2</strong> = The modulus/remainder operator with respect to 2. Numbers can only be 0 or 1 in this reality.
        </div><br><br>

	  
	  
    	  <strong><a href="#PrimitivePolyDef"><span class="mw-headline" id="PrimitivePolyDef">#</span></a> <font color="#006400">Primitive Polynomials</font></strong>: A form of irreducible polynomials, akin to a "prime" polynomial, with the only "factors" being 1 and the polynomial itself. [[[[[[[EXPLAIN IN A MORE COHESIVE AND FULLY ELABORATED MANNER[[[[[[[[.
        <br><br><br>
        
	      
	      
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Types of LFSRs:</strong><br><br>
      	  In practice, there are three types of LFSRs, the properties of which are the result of the feedback coefficients and degree.
      	  
      	  <ol>
      	  
        	  <li><strong>Primitive Polynomial-based</strong>: These LFSRs are composed of primitive polynomials (see definition), and produce a maximum-length sequence, the only LFSRs to do so.
        	  
        	  </li><br>
        	  
        	  <li><strong>Non-Primitive Irreducible Polynomial-based</strong>: Using irreducible polynomials that are not "primitive", these LFSRs produce a period that is totally independent of the initial value/"state" of the register. These algorithms do <strong><u>not</u></strong> produce maximum-length sequences.
        	  
        	  </li><br>
        	  
        	  <li><strong>Reducible Polynomial-based:</strong> These LFSRs have a sequence/period <em>dependent</em> on the initial state of the register. Of course, these algorithms can never produce a maximum-length sequence.
        	  
        	  </li><br>
      	  
      	  </ol>
      	  
      	  </div>
	  
	  
	        <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> The <strong>Period</strong> is the number of different strings of numbers that can occur in a specific LFSR before repeating. In a generic LFSR with 3 flip-flops, (such as that given in the LFSR Exposition - see Rule 31), this number is 7, e.g. all possible states.<br><br>
      	  A simple principle can thus be derived: <strong>The maximum <em><u>possible</u></em> period (or sequence length) generated by an LFSR of degree m is 2<sup>m</sup> - 1.</strong><br><br>
      	  
      	  As soon as a previous bit pattern/sequence (a 'state') is reached, then the cycle will repeat itself. Only certain feedback configurations (P<sub>m-1</sub>, ..., P<sub>0</sub>) yield maximum length sequences, regardless of the initial bit pattern/state (!). For any LFSR with a set number of flip-flops, m, and a given positioning/number of XOR gates, no matter what the initial state is, the period will always be the same.<br><br>
      	  
          This is why the given value is the maximum <em>possible</em> period of an LFSR - only some reach it.<br><br>
          There are patterns within the LFSR, specifically that of the positioning of the XOR gates with respect to the degree m, that can be used to determine if an LFSR will produce a maximum-length period or not - see Rule 37 for more information. These patterns require knowledge of the Polynomial Representation of LFSR's - see Rule 35.

	        </div><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> The only string of bits that can never appear in an LFSR is straight 0's. Such a thing is only possible if the initial setting is all straight 0's, which is a ridiculous thought not to be entertained.
	      </div><br><br>
	    
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Polynomial Representation of LFSR's</strong>:<br><br>
      	  All that is needed to represent the nature of an LFSR (devoid of the initial state) is the degree m (the number of flip-flops), and the feedback coefficients. These characteristics can be represented in simple polynomial form:<br><br>
      
          <strong>P(x) = x<sup>m</sup> + P<sub>m-1</sub> × x<sup>m-1</sup> + ... + P<sub>1</sub> × x + P<sub>0</sub></strong><br><br>
          
          <strong>m</strong> = The number of flip-flops. <br>
          <strong>x</strong> = The simple polynomial variable, nothing to be plugged in.<br>
          <strong>P<sub>m-1</sub></strong> = The feedback coefficient of the very first multiplier function (and thus, the flip-flop it represents) in the sequence. P<sub>m</sub> would be to the left of the first flip-flop, along the very end of the feedback path, and thus is always 1 and is unnotated. The sequence P<sub>m</sub> to P<sub>0</sub> represents all multiplier functions, left to right.<br><br>
          
          For example: The LFSR depicted in Rule 31 would be represented as x³ + x + 1.<br><br>
          
          Even if there were no XOR gates in the entire LFSR, then the equation would still be x<sup>m</sup> + 1, representing the ending and beginning points of feedback path.<br><br>
          What you are really looking at when you see a polynomial expression of an LSFR is the degree of the first term, and all of the terms in between the first term and the last term, because there is always going to be a +1 at the end. Otherwise, the output would not be incorporated into the feedback path, which is utterly preposterous and is never seen in the real world.<br><br>
          
          There are patterns in LFSR polynomials that can be used to determine whether the LFSR has a maximum-length period or not: see Rule 37.
      	  </div><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <u><span class="rule-number"></span></u>.<!--a wonderful milestone in any subject.--></font>
        </strong> <strong>Deriving Maximum-Length Periods from LFSR Polynomials:</strong><br><br>
    	    <strong>Only LFSR's with primitive polynomials</strong> (see definition) <strong>yield maximum-length sequences.</strong> <br><br>
    
          Below is a table showcasing an example primitive polynomial for each m value 2-128. Note that there are multitudes of primitive polynomials for any given m value, too many to produce a complete list. There are 6.92 × 10⁷ primitive polynomials for an LFSR of m 31.<br><br>
          In the table below, take the values as representing the degrees in reverse order: x^0 + x^1 + x^2, for example. This ensures the +1, a necessary component of any LFSR polynomial as explained in Rule 36.<br><br>
          <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/LFSRTable.png"><img src="/cryptography/img/LFSRTable.png" alt="A table showcasing an example primitive polynomial for each m value 2-128." width=78%/></a></div>
    	    <span class="tiny"><em>A table showcasing an example primitive polynomial for each m value 2-128.</em></span>
    
          </div><br><br>
	  
	  
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>HOW TO CRACK A LINEAR FEEDBACK SHIFT REGISTER (LFSR):</strong><br><br>
	  
      	  While Linear Feedback Shift Register's have the properties of relative randomness and are exceedingly efficient (with 100 flip-flops, a miniscule amount of space in hardware, producing a period of 2¹⁰⁰ - 1), it fails on the last hurdle: <em>unpredictability</em>. <br><br>
      	  
      	  By its very nature, an LFSR is a <u>deterministic</u> means of producing a keystream, thus opening it up to vulnerabilities that can be exploited. The main principle that must be acknowledged in attempting to 'break' or 'crack' any stream cipher that utilizes an LFSR is as follows:<br><br>
      
          <strong>If an attacker knows (at least) 2m output values of an LFSR, he can recover the entire LFSR configuration.</strong><br><br>
          
          <!--Recall that the LFSR is merely a keystream generation algorithm, providing the keystream to a simple stream cipher. Thus, both the equations of the stream cipher and those specific to the LFSR can be used in cracking it.<br><br>-->   <!--budget cuts, rule is very long and this explanation is kind of obvious.--> 
          
          Oscar, as always knows the complete ciphertext string. Furthermore, he knows the degree m of the LFSR, and, most damningly, he knows the first few plaintext characters: x<sub>0</sub>, ..., x<sub>2m - 1</sub>. With the header information, it is still realistic for that amount of plaintext to be known to the attacker.<br><br>
          
          Given this knowledge, Oscar simply has to follow a 3-step process in order to recover the entire key:<br><br><br>
          
          <strong>Step 1</strong>: <br>Utilizing the definition of the encryption function of a stream cipher, the keystream at position i can be isolated:<br><br>
          
          i ∈ <strong>ℤ</strong><sub>2m</sub><br><br>
          <strong>S<sub>i</sub> ≡ (x<sub>i</sub> + y<sub>i</sub>) mod 2</strong>.<br><br>
          
          Thus, Oscar is able to recover the first 2m output bits (the output/keystream bits) of the LFSR, which is <u>not enough:</u> the maximum possible period is 2<sup>m</sup> - 1, so there remain a considerable number of output bits that need to be recovered.<br><br><br>
          
          <strong>Step 2</strong>: <br>In order to discover the remaining bits, the feedback coefficients of the multiplier functions must be discovered. This is done using the generalized summation equation of the LFSR. Expanding out the summation will produce the following equation:<br><br>
          
          <strong>S<sub>m</sub> ≡ (S<sub>m-1</sub> × P<sub>m-1</sub> + ... + S<sub>0</sub> × P<sub>0</sub>) mod 2</strong><br><br>
          
          The only unknowns in this equation are every single feedback coefficient. Thus, there are a total of m unknowns that need to be solved for. In order to solve for the total of m unknowns, a system-of-equations type problem, with m equations, must be created:<br><br>
          
          <strong>S<sub>m</sub> ≡ (S<sub>m-1</sub> × P<sub>m-1</sub> + ... + S<sub>0</sub> × P<sub>0</sub>) mod 2</strong><br><br>
          
          <strong>S<sub>m+1</sub> ≡ (S<sub>m</sub> × P<sub>m-1</sub> + ... + S<sub>1</sub> × P<sub>0</sub>) mod 2</strong><br><br>
          .<br>
          .<br>
          .<Br><br>
          
          <strong>S<sub>2m-1</sub> ≡ (S<sub>2m-2</sub> × P<sub>m-1</sub> + ... + S<sub>m-1</sub> × P<sub>0</sub>) mod 2</strong><br><br>
          
          As was done for Linear Congruential Generators, each unknown can easily be solve for by Gaussian Elimination ([[[[[) or Matrix Inversion ([[[[[[[[).<br><br><br>
          
          
          <strong>Step 3</strong>: <br>Now that Oscar knows all of the Feedback Coefficients, he can build the LFSR himself.<br><br>
          
          He can determine the initial state using the output bits that are already known (using the Diagonal Rule, see Rule 31), and from there he will be able to compute the full keystream, S<sub>2m+1</sub> and beyond.<br><br>
          
          With the keystream, Oscar will now, of course, be able to recover the full plaintext:<br><br>
          
          <strong>x<sub>i</sub> ≡ (y<sub>i</sub> + s<sub>i</sub>) mod 2</strong>
      	  </div><br><br>
	  
	  
	  
	    </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="AltSecureStream">III.IV Alternate Secure Stream Ciphers.</span></h3>
	    </header>
	    <article>
	  
    	  <strong><font color="blue"><a href="#ModernCiphers"><span class="mw-headline" id="ModernCiphers">#</span></a> The Development of Modern Stream Ciphers:</font></strong><br><br>
    
        During the 1990s, stream ciphers were a center of attention for many cryptanalysts, who ruthlessly revealed vulnerabilites and weaknesses that opened particular popular ciphers of the time - this would fuel the predominance of block ciphers in modern cryptographic communications. <br><br>As a result, the eSTREAM project was established in 2004 by the "European Network of Excellence in Cryptology" (an E.U. front), which called for the development (and expert selection) of stream ciphers.<br><br> By 2008, several new, highly secure stream ciphers were developed, divided into two main categories/profiles:<br><br>
        
        <strong>1.</strong> Stream ciphers designed for implementation in software with high-volume data transfer requirements. Examples: Salsa20 (see Rule 39) & ChaCha (see Rule [[[[).
        <br><br>
        
        <strong>2.</strong> Stream ciphers designed for hardware implementation, with low power consumption, storage capabilities, and gate counts. Example: Trivium (see Rule [[[[).
        <br><br><br>

	  
    	  <strong><a href="#ARXORDef"><span class="mw-headline" id="ARXORDef">#</span></a> <font color="#006400">Add-Rotate-XOR (ARX) Ciphers</font></strong>: An algorithm in a cryptosystem that only uses additions, rotations, and XOR operations to generate its keystream.
        <br><br><br>
    	  
    	  <strong><a href="#NonceDef"><span class="mw-headline" id="NonceDef">#</span></a> <font color="#006400">"Nonce"</font></strong>: A number used only once.
        <br><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Salsa20:</strong><br><br>

          <strong><u>Mathematical Definition</u></strong>:<br><br>
          
          [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
          
          
          <strong><u>Explanation:</u></strong><br><br>
          
          
          
          
          <strong>"Salsa20"</strong> is a family of profile-1 stream ciphers, developed in 2005. The PRNG utilizes a 32-bit ARX framework, with additional layers of security added through increased 'rounds' of encryption: the base cipher (Salsa20/20) uses 20 ciphers, while reduced-round, faster varients use 12 rounds (Salsa20/12) and 8 rounds (Salsa20/8), respectively.<br><br>
          
          Salsa20/20 (hereafter referred to as "Salsa20") supports key-lengths of either 128 or 256 bits, though 256 is recommended. 
          
          [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
    
          </div><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> [[[[[Reserved for Future Usage. If additional rules are needed, then the <a href="/information/color.html#WoO">WoO system</a> will be used.[[[[[
	  
      	  [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20, ChaCha, and Trivium"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
      	  
      	  </div><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> [[[[[Reserved for Future Usage. If additional rules are needed, then the <a href="/information/color.html#WoO">WoO system</a> will be used.[[[[[
	  
    	  [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20, ChaCha, and Trivium"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
    	    </div><br><br>
	    
	    
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> [[[[[Reserved for Future Usage. If additional rules are needed, then the <a href="/information/color.html#WoO">WoO system</a> will be used.[[[[[
	  
    	  [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20, ChaCha, and Trivium"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
    	    </div><br>
	    
	  
	    </article>
	   </div>
	</div>
	
	<div class="General links">
		links
		<hr>
		Programming
		<a href="https://www.youtube.com/watch?v=8jLOx1hD3_o">Short C++ Tutorial</a><br>
		<a href="https://codeforces.com/blog/entry/125639">Code</a><a href="https://www.youtube.com/@tmwilliamlin168/videos">forces</a><br>
		<a href="https://www.youtube.com/playlist?list=PLGs0VKk2DiYw-L-RibttcvK-WBZm8WLEP">Arduino Tutorial</a><br>
		<a href="https://www.youtube.com/playlist?list=PLGs0VKk2DiYz8js1SJog21cDhkBqyAhC5">MicroPython</a><br>
		<a href="https://matplotlib.org/cheatsheets/">2D Python Plots</a><br><br>
		MIDI<br>
		<a href="https://www.anvilstudio.com/">Anvil Studio</a><br>
		<a href="https://meme.institute/gxscc/">GXSCC</a><br><br>
		Physics<br>
		<a href="https://www.feynmanlectures.caltech.edu/I_toc.html">Feynman Lectures</a><br>
		<a href="https://www.youtube.com/@FlippingPhysics/playlists">Physics Intro.</a><br>
		<hr>
		<a href="https://ocw.mit.edu/"><img src="/_other/ocw_logo_orange.202255b67af1a72a1f52.png" width=90%></a>
		<a href="https://www.eff.org/issues/innovation"><img src="/_other/eff.png" width=90%></a>
		<a href="https://archive.org/donate"><img src="/_other/internetarchive.gif" width=60%></a>
	</div>
      
</div>
      <footer class="site">
      <br>
        <strong><a href="/cryptography/symmetry.html">Symmetric Cryptography</a></strong><br>
        <article><strong><a href="/cryptography/symmetricFull.html">Complete Symmetric Cryptography</a></strong></article>
        <br>
        <article><strong><a href="/cryptography/symmetric/intro.html">Introductions</a></strong> → <strong><a href="/cryptography/symmetric/historical.html">Historical Ciphers & Modular Arithmetic</a></strong> → <strong>Stream Ciphers</strong> → <strong><a href="/cryptography/symmetric/block.html">Block Ciphers</a></strong><!-- → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong>--></article>
      	<br>
      	<hr>
      	<span class="tiny">Last Change: July 25 2025</span><br>
      	<span class="tiny">Jonathan Lacabe 2025</span><br>
      	<span class="tiny"><a href="mailto:jdlacabe@gmail.com">jdlacabe@gmail.com</a></span><br>
      	<img src="/_other/with_love%20(1).gif" width=9%>
      </footer>
      </div>
   </body>
</html>
