<!doctype html>
<html>
  <head>
  	<meta charset="UTF-8" />
    <title>Stream Ciphers (Symmetric Cryptography) Summary</title>
    <link href="/style.css" rel="stylesheet" />
    <link rel="icon" href="/favicon.ico">
  </head>
<body>
      <div class="wrapper">
      
      <header class="site" style="color: green; font-family: arial; line-height: 0em;">                                                                                                                      
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/javascript">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [["$", "$"], ["\\(", "\\)"]],
    },
    "HTML-CSS": {
      scale: 100, //Scale math to match surrounding text
    },
    displayAlign: "left", //Align equations to the left
  });
</script>

<script>
document.addEventListener("DOMContentLoaded", function (){
    //Loop through Rule containers
    let ruleContainers = document.querySelectorAll(".rules");
    ruleContainers.forEach(container =>{
        //Get starting Rule number, use 1 if unspecified.
        let startNumber = parseInt(container.getAttribute("data-start")) || 1;
        let rules = container.querySelectorAll(".rule");
        rules.forEach((rule, index) =>{
            let ruleNumber = startNumber + index;

            //Assign dynamic id to Rule container -> anchor link targets it
            rule.id = "Rule" + ruleNumber;

            //Update all elements displaying Rule #
            let numberElements = rule.querySelectorAll(".rule-number");
            numberElements.forEach(el => {
                el.textContent = ruleNumber;
            });

            //Update the href to target correct id, while preserving '#'.
            let ruleLink = rule.querySelector("a");
            if(ruleLink){
                ruleLink.href = "#Rule" + ruleNumber;
            }
        });
    });
});
</script>

<img src="/_other/logos/Symmetric_Encryption.png" width=36%><!--ALSO SPRACH ZARATHUSTRA.-->
<hr>
      	<span><em><a href="/information/art.html">Art by Shoaib Pasha.</a></em></span><hr>
      </header>

      <div class="inner">
	<nav>
		<div class="cont">
		  <a href="/index.html">Home</a><br>
		  <a href="/sitemap.txt">Sitemap</a><br>
		  <hr>
		  <a href="/Physics/physics.html">Physics</a><br>
		  <a href="/math/mathematics.html">Math</a><br>
		  <a href="/cryptography/cryptography.html">Crypto.</a><br>
		  <a href="/engineering/electric.html">Electric</a><br><!--It looks better as "Electric", considering Nuclear is without a period as well-->
		  <a href="/astronomy/astronomy.html">Astronomy</a><br>
		  <a href="/engineering/aeronautics.html">Aero.</a><br>
		  <a href="/engineering/nuclear.html">Nuclear</a><br>
		  <hr><!--Internal Pages-->
		  <a href="/information/recentchanges.txt">Recent Changes</a><br>
		  <a href="/information/color.html">Color Code</a><br>
		  <a href="/information/art.html">Logos</a><br>
		  <a href="/information/about.html#FAQ">FAQ</a><br><!--Will link to a section within the about page-->
		  <a href="/information/about.html">About</a><br>
		  <hr><!--All Mirrors-->
		  <a href="https://hkproject.org/">HKProject</a><br>
		  <a href="https://github.com/JonathanLacabe/JonathanLacabe.github.io">GitHub</a><br>
		  <a href="https://humanknowledge.neocities.org/">Neocities</a><br>
		</div>
	</nav>
	
	<div class="content">
	  <header class="articleHeader">
	    <h2>Summary of Stream Ciphers (Symmetric Cryptography)</h2>
	    <!--<h3><em>Theory > Application.</em></h3>-->
	  </header>
	  <hr>
	  <article>
	    <p>These are my complete notes for Stream Ciphers in Symmetric Cryptography. <br><br>I color-coded my notes according to their meaning - for a complete reference for each type of note, see <a href="/information/color.html">here</a> (also available in the sidebar). All of the knowledge present in these notes has been filtered through my personal explanations for them, the result of my attempts to understand and study them from my classes and online courses. In the unlikely event there are any egregious errors, contact me at <a href="mailto:jdlacabe@gmail.com">jdlacabe@gmail.com</a>.</p>
	  </article>
	  
	  <article><center><strong><h3>Table Of Contents</h3></strong></center></article>
	  
      <div class="toc-container">
        <div class="toc-column">
          <a href="#StreamIntro">III.I Intro to Stream Ciphers.</a>
        </div>
        <div class="toc-column">
          <a href="#LFSR">III.IV LFSRs.</a>
        </div>
      </div>
      
      <div class="toc-container">
        <div class="toc-column">
          <a href="#RNG">III.II Random Number Generation.</a>
        </div>
        
        <div class="toc-column">
          <a href="#AltSecureStream">III.V Alt. Secure Stream Ciphers.</a>
        </div>
      </div>
      
      <div class="toc-container">
        <div class="toc-column">
          <a href="#LFSRFundamentals">III.III Fundamentals of LFSRs.</a>
        </div>
        
        <div class="toc-column">
          <!--<a href="#AltSecureStream">III.VI Alt. Secure Stream Ciphers.</a>-->
        </div>
      </div>
      
      <div class="rules" data-start="24">
	  
	  <hr>
	    <header class="articleHeader"><hr>
	    <h2><span class="mw-headline" id="StreamCiphers">III. Stream Ciphers.</span></h2>
	    <h3><span class="mw-headline" id="StreamIntro">III.I Introduction to Stream Ciphers.</span></h3>
	  </header>
	  <article>
	  
	  <strong><a href="#Fig3"><span class="mw-headline" id="Fig3">#</span></a> Fig. 3. - Symmetric Cryptography Hierarchy:</strong><br>
      <div class="image-environment" role="img" aria-labelledby="image-alt-1"> <a href="/cryptography/img/cryptog.png" class="imglink"><img src="/cryptography/img/cryptog.png" alt="A Classification hierarchy of Symmetric Cryptography. There are two major branches of Symmetric Cryptography, Block Ciphers and Stream Ciphers. See Subsection I.I for the full tree, and see Rule 7 for Cryptanalysis." width=58%/></a></div>
	    <span class="tiny"><em>A Classification hierarchy of Symmetric Cryptography. There are two major branches of Symmetric Cryptography, Block Ciphers and Stream Ciphers. See Subsection I.I for the full tree, and see Rule 7 for Cryptanalysis.</em></span><br><br><br><br>
	  
	  
      <div class="rule"><strong>
          <a href="#Rule"><span class="hash">#</span></a> 
          <font color="red">C. Rule <span class="rule-number"></span>.</font>
      </strong> <strong>Modular 2 Operations</strong>:<br><br>
        In cryptography, when considering all of the mathematical operations commonly applied in primitives and ciphers, the <strong>modular 2 operation</strong> carries with it a set of properties and a reputation that makes it unique even within modular arithmetic.<Br><br>
        
        <strong>Mod 2 addition and subtraction are the same operation</strong>. Multiplication complicates things, but in all instances where the mod 2 function is limited to addition or subtraction, the results will be identical no matter which operation is applied.<br><br>
        
        <!--I purposely wrote this section with the sortf profound, "when there comes a time in human history" sorta vibe to it. Earl Sweatshirt - Off Top on repeat.-->
      
        With the smallest possible modulus that allows room for variation in the remainder<!--(since mod 1 produces straight 0s)-->, mod 2 operations are by and large the most popular application of modular arithmetic in cryptography. This is because their restriction of all numbers to be either 0s or 1s (by the very nature of a <em>modular operation</em>, see Rule 11) successfully emulates binary representation, making them extremely useful for bit-based computation (and in particular ciphers that intake streams of data, like stream ciphers (see Rule 25)).<br><br><!--Intake is a verb now. Jonathanization of the english language. 'atleast' and 'eachother' are also words now. -->
        <!--it has assumed a life almost detached from modular arithmetic-->
        
        The modular 2 operation is used so often, it has its own symbol in cryptographic diagrams: <strong>a circle with a cross</strong>. See Rule 25 for an example. In electrical engineering, the mod 2 function is known as the <strong>XOR gate</strong>, a type of binary gate (see E.E. [[[[[), further showcasing the broader importance of modular 2 operations in science as a whole. <br><br>
        
    	  Note that the listed properties do <STRONG>NOT</STRONG> extend to the modulus of any other number - only for two. See the Vigen√®re Cipher (see Rule 21), which works akin to a stream cipher, for proof using mod 26 (hint: the addition and subtraction operations produce different values).
    	  
    	 </div><br><br><br>
      	 
      	 
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Stream Ciphers</strong><br><br>

      <strong><u>Mathematical Definition</u></strong>:<br><br>
      
      <em>
      (x<sub>i</sub>, y<sub>i</sub>, s<sub>i</sub>) ‚àà <strong>‚Ñ§</strong><sub>2</sub><br><br>
      <strong>Encryption</strong>: <strong>e<sub>s<sub>i</sub></sub>(x<sub>i</sub>) ‚â° (x<sub>i</sub> + s<sub>i</sub>) mod 2</strong><br><br>
      <strong>Decryption</strong>: <strong>d<sub>s<sub>i</sub></sub>(y<sub>i</sub>) ‚â° (y<sub>i</sub> + s<sub>i</sub>) mod 2</strong>
      
      </em><br><br><br>
      
      <strong>x<sub>i</sub></strong> = The Plaintext bit at index i.<br>
      <strong>y<sub>i</sub></strong> = The Ciphertext bit at index i.<br>
      <strong>s<sub>i</sub></strong> = The <strong>"Keystream"</strong> at index i, equivalent to 'k' (as in past ciphers). Here, it is the Key (at index i) fed into the encryption and decryption functions.<br>
      <strong><strong>‚Ñ§</strong><sub>2</sub></strong> = A ring of the first 2 integers: {0, 1}. See Subsection II.III for an explanation of rings.<br>
      <strong>e<sub>s<sub>i</sub></sub>(x<sub>i</sub>)</strong> = Encryption function, a mathematical formula that converts each x bit into a y bit.<br>
      <strong>d<sub>s<sub>i</sub></sub>(y<sub>i</sub>)</strong> = Decryption function, a mathematical formula that converts each y bit into an x bit.<br>
      <strong>mod 2</strong> = The modulus/remainder operator with respect to 2. Numbers can only be 0 or 1 in this reality - see Rule 24 for a full treatise.
      
      <br><br><br>


      <strong><u>Explanation:</u></strong><br><br>
      A cipher that encrypts bits individually, processing one bit after another in a sequence. This is opposed to a Block Cipher (see Section IV), which takes in large numbers of bits all at once.<br><br>
      
      
      Using the modular 2 operation (see Rule 24), the encryption and decryption functions of the basic stream cipher can be depicted as shown in Fig. 4.<br><br>

        The central complexity of the Stream Cipher is the generation of the "Keystream", e.g. the stream of bits with which the plaintext is encrypted. This generation must be performed through <em>Random Numbers</em> - see Rule 26.<br><br>
        
        If the keybit (s<sub>i</sub>) is zero, then the plaintext bit will pass through unchanged, but if the keybit is 1, then the plaintext bit will flip (like binary). Thus, if the keystream (by divine intervention) is straight 0's, then the plaintext will go unencrypted. 
        
        <!--Most beautiful 90 seconds in Cryptography:
        https://youtu.be/AELVJL0axRs?list=PL2jrku-ebl3H50FiEPr4erSJiJHURM9BX&t=1520
        
        the Mozart Piano Concerto #21 Andante of Cryptography lecture segments
        
        -->
	      </div><br><br><br>
	      
	      
	      
	      <strong><a href="#Fig4"><span class="mw-headline" id="Fig4">#</span></a> Fig. 4. - Practical Stream Ciphers:</strong><br>
          <div class="image-environment" role="img" aria-labelledby="image-alt-1"> <a href="/cryptography/img/PracticalStream.png" class="imglink"><img src="/cryptography/img/PracticalStream.png" alt="A diagram of how all practical stream ciphers should function, with the modular 2 addition highlighted and the keystream generator (which varies from cipher to cipher) displayed." width=79%/></a></div>
    	    <span class="tiny"><em>A diagram of how all <em>practical</em> stream ciphers (abiding by the encryption and decryption functions defined in Rule 25) function, with the modular 2 addition highlighted and the keystream generator (which varies from cipher to cipher) displayed. Note that the key distribution is not depicted.</em></span><br><br><br><br>
	      
	  
	  
	      <strong><a href="#KeyStreamDef"><span class="mw-headline" id="KeyStreamDef">#</span></a> <font color="#006400">Keystream</font></strong>: A <u><em>stream</em></u> of characters that is combined with the plaintext to produce the ciphertext in a Stream Cipher, or, in the case of asynchronous stream ciphers, combined with a previous ciphertext to produce a new ciphertext.<br><br>

        The keystream is derived from the <u><em>key</em></u> and the <u><em>seed</em></u>. Generally, the keystream is denoted as "s<sub>i</sub>", while the seed itself is s<sub>0</sub>, the initial position/keybit of the stream from which all recursive stream ciphers evolve from in their encryption functions. Inherently, the number of possible seeds is the same as the <strong>keyspace</strong>, since the number of seeds dictates how many keys there can be.<br><br>
        
        The creation of a keystream (both key and seed) involves random number generators, which are detailed in Subsection III.II. The seed, for example, may be created using an actual True Random Number Generator (see Rule 26), while the rest of the key will be deterministically generated <em>from</em> that seed using a PRNG (also Rule 26).<br><!--I was just like, what the hell do I do with all of these parentheticals that are ruining the flow of the thing? asterixize them, of course!-->
        
        <!--**at least all ciphers that use a PRNG algorithm, like the LCG (see Rule 28).-->
        <br><br><br>
	  
	  
    	  <strong><a href="#SynchronousStreamDef"><span class="mw-headline" id="SynchronousStreamDef">#</span></a> <font color="#006400">Synchronous Stream Cipher</font></strong>: A Stream Cipher in which the keystream depends solely on the key, generated independently of the plaintext or ciphertext. Examples include Salsa20 & ChaCha.
        <br><br><br>
        
    	  
    	  <strong><a href="#AsynchronousStreamDef"><span class="mw-headline" id="AsynchronousStreamDef">#</span></a> <font color="#006400">Asynchronous Stream Cipher</font></strong>: A Stream Cipher in which the keystream depends on the ciphertext in addition to the key - the key generation is reliant on previous ciphertext, making it a risky operation. An example is the Cipher Feedback (CFB) mode, described in Rule [[[.
        <br><br><br>
        
	  
	      
	    </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="RNG">III.II Random Number Generation.</span></h3>
	    </header>
	    <article>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Random Number Generators (RNG)</strong>:<br><br> The means with which a system can generate random numbers, for the purposes of constructing/filling a keystream with random bits, are split into three main mechanisms:<br><br>

        <ol>
          <li> <strong>True Random Number Generators (TRNGs)</strong>: "True" random numbers stem from random physical processes that cannot be reproduced. Such <em>natural</em> sources of entropy include flipping a coin, rolling a die, thermal noise, mouse movement, and keystroke timing.<br><br>
          
          Hardware and cryptographic systems have tried a lot of different techniques over the years to create a TRNG by analyzing/recording internal characteristics of the computer. Most modern CPU's have a TRNG within a TPM  (trusted platform module) on the motherboard.<br><br>
          
          An example of a cipher that <em>completely</em> uses TRNGs (not just for one element like the seed, but for the <u><em>entire keystream</em></u>) is the One Time Pad, detailed in Rule 27.
          
          </li><br><br>
          
          
          <li> <strong>Pseudo Random Number Generators (PRNGs)</strong>: An RNG system that is random, but reproducable. Because PRNG's are computed, they are inherently deterministic processes. Since they are deterministic, Alice and Bob can generate the same keystream independently of one another, only needing to know the initial "seed", which is like the key for the key (see the "Keystream" definition).<br><br>
          
          With respect to Stream Ciphers, another commonly-used term is "<strong>PRBS</strong>" (Pseudo-Random Bit/Binary Sequences), which is just a more stream-specific way of looking at what these generators are actually <em>producing</em>.<br><br>
          
          Often, PRNG's are computed with the following function:<br><br>
          
          <strong> s<sub>i+1</sub> = f(s<sub>i</sub>)</strong><br><br>
          
          <strong>s<sub>0</sub></strong> = The initial seed value, which may be an actual TRNG.<br>
          <strong>f(s<sub>i</sub>)</strong> = The 'randomizer' function, which performs whatever upon the seed
          in order to computationally randomize it.<br><br>
          
          This recursive generation is the form taken by the Linear Congruential Generator, an example of a cryptosystem utilizing a PRNG (see Rule 28). <br><br>
          The rand() function in C is a PRNG and uses a seed of 12345, with the following function as the randomizer: <br>S<sub>i+1</sub> = ((1103515245 √ó s<sub>i</sub>) + 12345) mod 2¬≥¬π.
          </li><br><br>
          
          
          <li><strong>Cryptographically Secure Pseudorandom Number Generators (CSPRNGs/CPRNGs)</strong>: PRNG's that have an additional property: the numbers must be <strong><u>unpredictable</u></strong>.<br><br>
          
          Given n output keybits (s<sub>i</sub>, s<sub>i+1</sub>, ..., s<sub>i+(n-1)</sub>), it is computationally infeasible to construct s<sub>i+n</sub>.<br><br>
          
          While in most applications (read: the world outside cryptography), PRNG systems are perfectly fine and suited to create 'random' numbers for whatever purpose, they form very unsecure cryptosystems due to their inherently deterministic nature, and thus in Cryptography, the additional property of unpredictability is required. An example of a commonly-used CPRNG in the real world is the [[[.
          
          
          </li>
        
        </ol>
        </div><br><br>


        <strong><a href="#UnconditionalSecurityDef"><span class="mw-headline" id="UnconditionalSecurityDef">#</span></a> <font color="#006400">Unconditional Security</font></strong>: A cipher is "unconditionally secure" (or "information-theoretically secure") if it cannot be broken even with <u>infinite</u> computing resources. <br><br>
        
        Even if a key is 2^1000 bits, it would not be considered "unconditionally secure", because 2^1000 computers (a patently <u>not</u> infinite amount of computers) would be able to break the key in one second. This is despite the fact that such levels of computing power will never be realized in human history.<br><br> 
        Thus, though there are very many ciphers that are "practically" secure (forming the backbone of our modern cybersecurity systems), they are not unconditionally secure.
        <br><br><br>
        
        
        <strong><a href="#ComputationalSecurityDef"><span class="mw-headline" id="ComputationalSecurityDef">#</span></a> <font color="#006400">Computational Security</font></strong>: A cryptosystem is computationally secure if the best known algorithm for breaking it requires at least t operations, where 't' is some ridiculous number far beyond the reach of modern brute-force computational abilities.
        <br><br><br>

	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>One Time Pad (OTP)</strong><br><br>
          The <strong>One Time Pad</strong> (also referred to as the "<strong>Vernam cipher</strong>") is an example of a TRNG-based cryptosystem. It is <em>the</em> unconditionally secure, totally unbreakable, perfect encryption algorithm. The OTP is a stream cipher with the following properties:<br><br>
          1) The Keystream bits s<sub>i</sub> must originate from a True Random Number Generator (a 'TRNG', see Rule 26, 1.).<br><br>
          2) Each Keystream bit must be used only once.<br><br>
          
          Knowledge of the Keystream must be exclusively limited to the involved parties, of course. At the end of the data transfer, the party that received the data must destroy the key so that it cannot be used by another party to decrypt the message after the fact. This is the same reason why reusing keys is extremely risky and nullifies the security benefits of the OTP.<br><br>
          
          The security of cryptosystem draws from the fact that, without knowledge of the keystream, even a brute-force attack would be futile, because any two text strings are equally as probable to be a particular word in the plaintext: if a four letter word were to be encrypted, it is equally probable for it to be "when", "stop", or "abcd".<br><br>
          
          There is one fundamental drawback of the OTP, however, that prevents its universal application: since keystream bits cannot be reused, <strong>the key has to be as long as the plaintext</strong>. A 400MB file, 8 bits to the byte, would entail a 3.2GB key. As such, the One Time Pad is not the be-all-end-all of Cryptography (at least in terms of application), and other types of CPRNGS are still relevant.
          </div><br><br><br><br>
          
          
          
          
          
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Linear Congruential Generator (LCG)</strong>:<br><br>

          <strong><u>Mathematical Definition</u></strong>:<br><br>
          
            <em>
            (A, B, i, S<sub>i</sub>) ‚àà <strong>‚Ñ§</strong><sub>m</sub><br>
            i > 0<br>
            Key K = (A, B)<Br><br>
            
            <strong>S<sub>i + 1</sub> ‚â° ((A √ó S<sub>i</sub>) + B) mod m</strong>
            
            </em><br><br><br>
            
            <strong>S<sub>0</sub></strong> = The initial seed value, which may have been created using a TRNG. Of course, it is not depicted in the equation as the equation only refers to i > 0. The seed value is exactly ‚åàlog<sub>2</sub> m‚åâ bits long, explained below. <br>
            
            <strong>S<sub>i</sub></strong> = The Keystream at index i, where i > 0. It is exactly ‚åàlog<sub>2</sub> m‚åâ bits long, explained below. <br>
            
            <strong>S<sub>i + 1</sub></strong> = The following value in the keystream, which is recursively calculated using the value of the previous bit in the keystream (along with the key). It is exactly ‚åàlog<sub>2</sub> m‚åâ bits long, explained below.<br>
            
            <strong>A</strong> = The multiplied value of the key. It is exactly ‚åàlog<sub>2</sub> m‚åâ bits long, explained below. <br>
            
            <strong>B</strong> = The "shift parameter" value of the key, only used for the addition operation. It is exactly ‚åàlog<sub>2</sub> m‚åâ bits long, explained below.<br>
            
            <strong><strong>‚Ñ§</strong><sub>m</sub></strong> = A ring of m integers. See Subsection II.III for an explanation of rings.<br>
            
            <strong>mod m</strong> = The modulus/remainder operator, which represents the usage of modular arithmetic, with all numbers represented by their remainder with respect to m.
            <br><br><br>
          
          
          <strong><u>Explanation:</u></strong><br><br>
          
          The LCG is a PRNG-based keystream generator, using the attributes of the key and the seed as its base components. It is an example of a non-cryptographically secure PRNG, the 2nd type of RNG detailed in Rule 26. This makes it more practical a system than the One Time Pad (see Rule 27), but much easier to break (see Rule 29). The keystream is deterministically created using a recursive function originating at S<sub>0</sub> (the seed), which itself may be created using a TRNG.<br><br>
          
          Of course, separate from the nature of the function/equation itself, note that there are no "Encryption" or "Decryption" functions, because the given equation is merely for composing the keystream (PRNG-style - see Rule 26), while the equation for the Stream <em>Cipher</em> itself remains the same (see Rule 25).<br><br>
          
          The Linear Congruential Generator bears many similarities to the Affine Cipher (Rule 22), in particular how the key is split into multiple parameters (in the case of the LCG, the key used to generate the key<em>stream</em>). However, the <em>length</em> of the parameters greatly differs between the two - while affine ciphers have a set, immutable value for their keyspace, LCG variables derive their length from the modulus itself.<!--I left this sentence as essentially a stream-of-consciousness placeholder to revise later, basically just setting down my ideas so I could polish them later, only to find that it exactly conveyed the point I was trying to get across, in pretty good diction as well. Didn't change a word.--><br><br> 

          	Note that because the modulus represents a set/ring, <strong>‚Ñ§</strong><sub>m</sub>, m qualifies for the set-based bit-length (as detailed in Rule 4). As such, the fact that variables A, B, and S<sub>i</sub> are all ‚åàlog<sub>2</sub> m‚åâ bits long means that <strong>they are as long as the bit-length of the modulus</strong>.<br><br>
          
          Of course, since m is not the keyspace, ‚åàlog<sub>2</sub> m‚åâ is only in reference to a set-based bit-length and not to the key-length. As such, no determination regarding the keyspace of the LCG can be made from ‚åàlog<sub>2</sub> m‚åâ, as the equation for finding it using a set-based bit-length (as extensively discussed in Rule 6) specifically requires the <em>key-length</em>. As a bit-based cryptosystem, the LCG <em>does</em> have a key-length (considering it literally generates keys), just not one equal to the bit-length of m.<br><br>
          
          <!--essentially an alternate version of the intro to the previous paragraph. the specification as to how the confusion lies in how the keylength equation is used much more than the set-based bit-length one would have to be worked in to make it functional, but the current one is pretty good anyways:
          Thus, the usage of the equation with m in the usual place of the keyspace does <u>not</u> mean that m is literally the keyspace - this is the fool's conclusion from a cursory glance of the equation.-->
          
           ‚åàlog<sub>2</sub> m‚åâ, as the set-based bit-length of m, merely represents the total number of bits required to represent a variable who can have any value between 0 and m-1. To say that A, B, and Si all have a length of ‚åàlog2 m‚åâ bits does not mean that they are all the same value, but just that they all use the same number of bits to represent their values. For example, 00001 and 11111 represent different values in binary, but both have a bit-length of 5.<br><br><br>
          
          The exact reasonings behind <em>why</em> each variable has a bit-length of m, and how things like the key-length and keyspace are calculated, are subject to the design choices of the Linear Congruential Generator itself. As LCGs are PRNGs, understanding the intricacies of these design choices and the exact purpose behind each part of this particular system is irrelevant to learning Cryptography.<br><br>
          
          The decisions made in designing this RNG were not made from a cryptographic standpoint, and thus warrant no in-depth analysis as to aspects like key-length and keyspace size, as the LCG will never be used in a cryptographic context.<br><br>
          
          The mathematics behind the logic for the aforementioned calculations are thoroughly complex and higher-level, and to describe them in great detail would serve no purpose in a cryptography-focused course. Rather, LCGs are useful for their discussion of how PRNGs can be cracked relatively easily (see Rule 29).
          
          <!--FINALLY. I had to add three additional Rules and an entire new Subsection to get to this point. In omnia scientia quaerere-->

          
          
          <!--Apparently, these things have the craziest mathematics behind their functioning, for the key-length and keyspace: LCG constraints often force ùê¥ A to lie in the multiplicative group modulo ùëö m, whose size is ùúë ( ùëö ) œÜ(m) (Euler‚Äôs totient).
          
          They are cryptologically insecure anyways, so whatever, but just note that this things are totally complex. Note what Paar said - there is a huge amount of research and textbooks discussing PRNGs for non-cryptographic purposes, but they are all irrelevant because they are not cryptographically secure.-->



        <!--
        not sure if this unfinished paragraph is true or not, can't find any good information about it, and I am not exerting a huge amount of effort into doing so because of how tangential and non-essential this section is to cryptography as a whole. ergo the "this is irrelevant and complicated mathematics" approach to explaining it.
        
        Note that the keyspace of a linear congruential generator is not calculated in the same fashion as an Affine cipher, however; whereas the affine cipher simply multiplied the components of the key (A & B) together to find the keyspace, the LCG (and all other ciphers that use a key to generate a keystream) is a bit more abstracted in its approach - 
        -->
          
          
          
          
          <!--Easily the hardest rule(s) I have had to write so far in Cryptography, 26 & 27. Took several hours of total concentration and thinking power, requiring the rewriting of portions of past rules and definitions as well.-->
          
          <!--note: Several months after making these Rules, while in the revisal process, it was once again this section that had me go back and edit and create a bunch of earlier Rules in order to better explain the key concepts at play here. The curse of the LCG strikes again.-->
	      </div><br><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>HOW TO CRACK A LINEAR CONGRUENTIAL GENERATOR (LCG):</strong><br><br>

        In order to crack a rudimentary LCG system and discover the full keystream to decrypt the system, the attacker only needs to know three characters of the plaintext that were encrypted (along with all of the ciphertext). Generally, in encrypting a document (such as Microsoft Word or Excel), there will be file or protocol header information at the start (like the version number), which will always be the same initial symbols being encrypted. Therefore, knowledge of the attacker of these plaintext characters, in addition to the ciphertext, can be assumed.<br><br>
        
        With knowledge of the LCG key-stream equation, the attacker would know S<sub>0</sub>, S<sub>1</sub>, and S<sub>2</sub> only. There would thus be three unknowns: A, B, and m. However, the set of commonly used m values is relatively small (see <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use">list</a>), and so iterating through them using brute-force (once A and B have been discovered) would be very simple: simply calculate the associated keystream for each possible m value, then check each keystream using the stream cipher decryption function (see Rule 25) and the known ciphertext, until the correct keystream (and thus m value) is found. Thus, m is considered one of the known variables.<br><br>
        <!--Since modular arithmetic dictates that all integers must be lower than the modulus (the remainder with respect to the modulus), the attacker can easily determine the modulus of a key generation algorithm by just finding the ciphertext keybit with the highest value and then adding one.-->
        
        The attacker only has to create a system of equations-style problem (using the three known plaintext characters and the ciphertext) in order to isolate A and B, respectively.<br><br>
        S<sub>1</sub> ‚â° ((A √ó S<sub>0</sub>) + B) mod m<br>
        S<sub>2</sub> ‚â° ((A √ó S<sub>1</sub>) + B) mod m<br><br>
        
        <strong>A = ((S<sub>1</sub> - S<sub>2</sub>) √ó (S<sub>0</sub> - S<sub>1</sub>)‚Åª¬π) mod m</strong><br>
        
        <strong>B = (S<sub>1</sub> - (S<sub>0</sub> √ó (S<sub>1</sub> - S<sub>2</sub>) √ó (S<sub>0</sub> - S<sub>1</sub>)‚Åª¬π)) mod m</strong><br><br>
        
        After finding A and B, all that would be left to be done is to brute-force m as previously described, and the system would be cracked. The full plaintext would be able to be decoded since every variable of the LCG would be known.
        
        </div><br><br>
      
      
      
      
      </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="LFSRFundamentals">III.III Fundamentals of Linear Feedback Shift Registers.</span></h3>
	    </header>
	    <article>
	    
	    <strong><font color="blue"><a href="#LFSRTerminology"><span class="mw-headline" id="LFSRTerminology">#</span></a> LFSR Terminology:</font></strong><br><br>
      Linear Feedback Shift Registers (LFSRs) are a type of keystream generator, and are fundamentally important primitives that serve as the building blocks of many ciphers. There is a large amount of terminology used with LFSRs that obfuscates the readability and coherency of any text describing them. Worse, some phrases/terms are more selectively applied than others and/or share meanings.<br><br>

      As such, to better adumbrate<!--:^)--> LFSRs to the beginning Cryptographer, all known LFSR-specific terminologies are described in detail within Subsections III.III & III.IV (alongside all prerequisite E.E. knowledge for LFSRs), legible for both straight-through reading (as you would approach a standard textbook) and for the 'ctrl-f'ing Cryptographer who encountered an unfamiliar term in the field. <!--All information is presented assuming knowledge of only the information that was previously explained.-->
      
      <br><br><br>
	  
	    <strong><a href="#CSEDef"><span class="mw-headline" id="CSEDef">#</span></a> <font color="#006400">Clocked Storage Element (CSE)</font></strong>: A storage container that captures information at a specific moment in time, storing it until needed. Think of it like a recording device built into the hardware of the computer, and it captures information at the moment a signal is sent to it (updating to replace whatever information was in it previously).<br><Br><!--completely intuitive explanation that should make sense to anyone without an inkling of e.e. knowledge, I am very proud of this one-->
	    
	    In more explicitly electrical engineering terms (for those more experienced in such regards), CSE's are part of <em>Clocking Subsystems</em> (see E.E. Rule [[[[[) and respond to Clock signals (see E.E. Rule [[[[[).
        <br><br><br><br>
	    
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> A "<strong>Flip-flop</strong>" is a clocked storage element that stores a single bit. There is an input, an output, and a <strong>Clock Input</strong> that determines whether any inputted bit is to be stored or not.<br><br>

        The general symbology used in diagrams for a flip-flop (in which D is the input & Q is the output) is as follows:<br><br>
  	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/D-flip-flop-basics.png" class="imglink"><img src="/cryptography/img/D-flip-flop-basics.png" alt="A diagram of the basic functions of the flip-flop electrical component. D is the input, Q is the output. Ignore the Q with the line for now. Courtesy of buildcircuitelectronics." width=53%/></a></div>
  	    <span class="tiny"><em>A diagram of the basic functions of the flip-flop electrical component. D is the input, Q is the output. Ignore the Q with the line for now ([[[)<!--wherever an explanation for this comes up, whether later on in Cryptgraphy or E.E., reference it here-->. Courtesy of <a href="https://www.build-electronic-circuits.com/d-flip-flop/">buildcircuitelectronics</a>.</em></span><br><br><br>
  
        And here is a diagram showing how the output relies on clock signals to accept an input change, if any:<br><br>
  	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/D-type_flip-flop_impulse_diagram.png" class="imglink"><img src="/cryptography/img/D-type_flip-flop_impulse_diagram.png" alt="A diagram detailing how the clock signal will influence what data from the input is stored and produced in the output. As shown, the flip-flop will only store the first event captured in the input when the clock signal becomes active, regardless of whether the input changes while the clock signal is still active. Courtesy of Wikipedia." width=60%/></a></div>
  	    <span class="tiny"><em>A diagram detailing how the clock signal will influence what data from the input is stored and produced in the output. As shown, the flip-flop will only store the first event captured in the input when the clock signal becomes active, regardless of whether the input changes while the clock signal is still active. Courtesy of <a href="https://commons.wikimedia.org/wiki/File:D-type_flip-flop_impulse_diagram.png">Wikipedia</a>.</em></span>
  	  
  	    </div><br><br><br>
  	  
  	    
  	    <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Shift Registers</strong>:<br><br> 
        
        A "shift register" is a concatentation of several individual flip-flops. Each flip-flop has a starting bit-value, which it then uses to send a signal to each following flip-flop until the final one, which will produce each bit of the output. The combined bits taken from the final flip-flop form a keystream, as depicted in the diagram below. The shift register is one half of an LFSR (see Rule 32).<br><br>
  	    
  	    Very important to notice in the progress of the bits of a shift register towards the output, is that there is a distinct pattern that holds for each bit-value (placed below the flip-flops on the diagram), known as the <strong>Diagonal Rule</strong>: each bit-value will be translated diagonally rightward and downward, for as many flip-flops as there are to the right. Note this pattern in the diagram below:<br><Br>
  
        An example of a shift register, with three flip-flops, with every new value sent receiving a clock signal:<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/ShiftRegisterDiag1.png" class="imglink"><img src="/cryptography/img/ShiftRegisterDiag1.png" alt="A shift register, complete with three flip-flops, and a starting value of 1-0-0. Data moves over once, and the Diagonal rule is used to create the new data values for the latter flip-flops." width=53%/></a></div>
  	    <span class="tiny"><em>A shift register, complete with three flip-flops, and a starting value of 1-0-0. Data moves rightward as the result of a clock signal allowing each flip-flop to take in the data of the flip-flop to its left, and the Diagonal rule becomes visible in how the data values effectively move diagonally to the right from their initial position.</em></span>
  	    
  	    </div><br><br>
  	  
  	    
        
        
	  
  	    </article>
  	    <header class="articleHeader"><hr>
  	      <h3><span class="mw-headline" id="LFSR">III.IV Linear Feedback Shift Registers.</span></h3>
  	    </header>
  	    <article>
	      
	      
	      
	      <strong><font color="blue"><a href="#LFSRIntro"><span class="mw-headline" id="LFSRIntro">#</span></a> Introduction to Linear Feedback Shift Registers:</font></strong><br><br>
        There is an inherent relationship between electrical engineering and Cryptography, specifically in how Cryptography developed: in the early days of the development of the Stream Cipher, the goal was to create a 'small' stream cipher, e.g. a stream cipher that could be implemented in hardware without using too much power.<br><br>
        
        Today, all stream ciphers fit one of two categories: ciphers optimized for <strong>software implementation</strong>, and ciphers optimized for <strong>hardware implementation</strong>. A prime example of the latter are "Shift Register-Based Stream Ciphers", in particular shift registers (see Rule 31) with a feedback mechanism, better known as Linear Feedback Shift Registers.
        
        <br><br><br><br>
        
	      
	      
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Linear Feedback Shift Registers</strong>:<br><br>

        <strong><u>Mathematical Definition</u></strong>:<br><br>
        
          <em>
          The equation depends on the specific characteristics of the LFSR. Specifically, the number of flip-flops, the number of mod 2 functions, and which flip-flops have mod 2 functions. The following formula applies to all LFSRs and is fully explained/derived in the LFSR Generalization (see Rule 33):<br><br><!--Looking back, I think I handled the problem of the equation well, since the equation is not explicitly explained or detailed in this Rule. For those wanting a refresher on the concept of the LFSR itself, this Rule is good, for those just needing the equation, this Rule is good, and those seeking to comprehend and understand the equation, this note is here to redirect them to the right place.-->
          
          (S<sub>i</sub>, P<sub>j</sub>) ‚àà <strong>‚Ñ§</strong><sub>2</sub><br>
          (i, j) ‚àà <strong>‚Ñ§</strong><sub>m</sub>
          </em><br><br>
          
          $$S_{m+i} \equiv \left( \sum_{j=0}^{m-1} S_{i+j} \times P_{j} \right) \mod 2$$<br>
          
          <strong>m</strong> = The number of flip-flops in the LFSR. This number determines both the length of the state register and the <em>period</em> (see Rule 34) of the output sequence.<br><br>
          
          <strong>i</strong> = The offset in the shift register, i.e., the number bit of the keystream that is being found. This is why it is <em>‚àà <strong>‚Ñ§</strong><sub>m</sub></em> - it can go no greater than m-1.<br><br>
          
          <strong>S<sub>m + i</sub></strong> = The bit inputted into the first flip-flop at the offset i, and outputted into the keystream at the offset m+i. That's the diagonal rule for you.<br><br><!--I lockedtf in and everything clickrf for me. writing tired, 7:39 am-->
          
          <strong>j</strong> = The index variable for each individual flip-flop, each of which has the <em>potential</em> to contribute to the feedback path, as determined by the feedback coefficient.<br><br>
          
          <strong>S<sub>i + j</sub></strong> = The bit held by a particular flip-flop j at a specific offset i in the shift register. This is the value being inputted into the multiplier function from the flip-flop.<br><br>
          
          <strong>P<sub>j</sub></strong> = The feedback coefficient of the multiplier associated with flip-flop j. Either 0 or 1.<br><br>
          
          <strong>mod 2</strong> = The modulus/remainder operator with respect to 2. Numbers can only be 0 or 1 in this reality - see Rule 24 for a full treatise.
          <br><br><br>
        
        <!--On God this is the best explanation of each variable. Human Knowledge is the greatest learning resource known to mankind, better than Wikipedia, better than any Alien knowledgebase.-->
  
        <strong><u>Explanation:</u></strong><br><br>
        
        Occasionally referred to as cryptographic "<em>linear recurrences</em>" by various demented individuals, <u><strong>Linear Feedback Shift Registers</strong></u> are yet another PRNG-based keystream generator, and are thus crackable with some effort (see Rule 39).<br><br>
        
        However, unlike other PRNGS like Linear Congruential Generators (see Rule 28) which have no function in real cryptography due to their absurd unsecurity, the LFSR finds application in many ciphers due to its usefulness as a <u>primitive</u><!--, a building block-->. These ciphers use multiple LFSRs to achieve greater security: the A51 cipher (see Rule [[[<!--potentially a Rule going over the cipher, or maybe just a detailing later on about how A51 ciphers are standard technology in phones and other technological appliances, if the Rule gets scrapped.-->), for example, consists of 3. This greatly enhances the security of the cipher and validates the usage of LFSRs for legitimate cryptographic purposes (see Rule [[[<!-- ", as a result of how [[[[" and then briefly describe why adding more is so effective, with the Rule going over the entire reason in full detail. potentially some Rule abour a cipher that uses the lfsr multiple times, but if it is super far ahead, then it would still be good to have a little explanation here detailing how adding more lfsrs increases the security by any means-->).<br><br>
        
        LFSRs incorporate a standard Shift Register (as detailed in Rule 31) alongside a <strong>feedback mechanism/path</strong>, generating fresh input for the first flip-flop using some output data. The feedback path extends from the output of the rightmost flip-flop (which, as known from the shift register analysis in Rule 31, is the flip-flop whose bits form the keystream) and inputs into the first flip-flop.<br><br>
        
        Placed along the feedback path are modular 2 addition functions (a.k.a. XOR gates, detailed in Rule 24), which are performed between the bit from the final flip-flop (by virtue of it being the beginning of the feedback path) and <u>atleast</u> one other in the shift register. Multiple XOR-gates can be added along the feedback path to create additional mod 2 operations (inherently meaning mod 2 operations involving the product of <em>another</em> mod 2 operation from earlier along the feedback path), complicating the structure of the LFSR and enraging Oscar.<br><br>
        
        The mod 2 calculation is first performed in the initial state of the shift register (the "<strong>initialization vector</strong>" of the shift register - see the "State" definition), before the first clock cycle, pre-computing the value that will be used as input for the first flip-flop <u>on</u> the first <strong>clock cycle</strong>. Every clock cycle adds another row of bits below the flip-flops, accounting for the clock signals sent to each flip-flop and their subsequent outputs.<br><br>
        
        Once the bit travels all the way through the feedback path, having been XOR'd 1+ times with the bits from various points in the register, it is simply fed into the first flip-flop so that the shift register can have a new input value. The value of the bit inputted into the first flip-flop is the result of the summation of all of the possible XOR operations that could be present in the LFSR.<br><br>
  
  
        Since Shift Registers are an integral component of LFSRs, the Diagonal Rule previously described for Shift Registers (see Rule 31) is retained for the movement of bits within an LFSR, as shown in the diagram below:<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/ShiftRegisterDiag2.png" class="imglink"><img src="/cryptography/img/ShiftRegisterDiag2.png" alt="A Linear Feedback Shift Register, complete with three flip-flops and a full period of values, which compose one complete keystream." width=75%/></a></div>
  	    <span class="tiny"><em>A Linear Feedback Shift Register, complete with three flip-flops and a full period of values, which compose one complete keystream.</em></span><br><br><br>
  
        The specific mathematical formula of the keystream produced by the depicted LFSR is (as a result of the diagonal rule): <strong>S<sub>i+3</sub> ‚â° (s<sub>i+1</sub> + s<sub>i</sub>) mod 2</strong>.
        
        
        </div><br><br><br>



        <strong><a href="#FeedbackDef"><span class="mw-headline" id="FeedbackDef">#</span></a> <font color="#006400">Feedback Path/Feedback Mechanism</font></strong>: The path that allows for bits to be inputted back into the Linear Feedback Shift Register using output data, forming the "Linear Feedback" part of the LFSR. The path extends from the output of the rightmost flip-flop and inputs into the first flip-flop.<br><br>
        
          Placed along the feedback path are modular 2 addition functions (a.k.a. XOR gates, detailed in Rule 24), which are performed between the bit from the final flip-flop (by virtue of it being the beginning of the feedback path) and <u>atleast</u> one other in the shift register.
        <br><br><br><br><!--reuses a bit of content from the lfsr Rule itself, but I am looking out for the ctrl-f'ing Cryptographer who wants to read an exact definition and doesn't have time to root through a whole Rule-->
        
        
        
        <strong><a href="#LFSRStateDef"><span class="mw-headline" id="LFSRStateDef">#</span></a> <font color="#006400">State/Offset (in regard to LFSRs)</font></strong>: The bits of the flip-flops at a particular row-position in the shift register. Given knowledge of an LFSR state and the XOR-positions/feedback path, every following row of bits can be determined.<br><Br>
        
        The first state of an LFSR is known as the <strong>Initialization Vector</strong>.<br><Br>
        
         Even without knowledge of the XOR positions, by pure knowledge of the first state, almost every flip-flop bit in the following state (except for the first F.F., the recipient of the input of the feedback state) can be determined, as a result of the <u>diagonal rule</u> of Shift Registers (see Rule 31).
        <br><br><br><br>
        
        
        
        <strong><a href="#TapsDef"><span class="mw-headline" id="TapsDef">#</span></a> <font color="#006400">Taps/Tap Sequences</font></strong>: Know that there are alternate terminologies used in more pretentious and snobbish cryptographic circles. In these contexts, each outputted bit is referred to as a <em><strong>tap</strong></em>, while the full list of taps is known as the <em><strong>tap sequence</strong></em>. In the Summary of Cryptography, for the sake of simplicity, these terms will only be referred to as the "<strong>output bits</strong>" and "<strong>keystream</strong>", respectively.
        <br><br><br><br><br>
        
        
        
        
        <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>LFSR Generalization:</STRONG><br><br> 

        To construct a generalized LFSR so that a general equation can be applied, several new mathematical operations must be introduced.<br><br>
        
        First, the number of flip-flops in the register can be generalized to an arbitrary 'm' value.<br><br>
        
        The second generalization is a bit more complex: Understand that it is possible for any flip-flop in an LFSR to have its bits fed into an XOR gate on the feedback path, and for there to be as many XOR gates as flip-flops (minus one, since the rightmost flip-flops share one). Since every flip-flop can have an XOR gate (and thus be apart of the feedback path), a <strong>multiplier function</strong> (labeled P<sub>0</sub> to P<sub>m-1</sub>) is added along each flip-flop's tentative connection to the feedback path, serving as an intermediary between the flip-flop and any possible XOR gate above on the feedback path. The multiplier essentially acts as an on-or-off switch, activating depending on whether there actually is an XOR gate for that particular flip-flop or not, as detailed below.<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/GeneralizedLFSR.png" class="imglink"><img src="/cryptography/img/GeneralizedLFSR.png" alt="A generalized LFSR, with every possible link between a flip-flop and the feedback path having a multiplier function, serving as the 'switch' determining whether that flip-flop is included as a part of the XOR operation." width=82%/></a></div>
  	    <span class="tiny"><em>A generalized LFSR, with every possible link between a flip-flop and the feedback path having a multiplier function, serving as the 'switch' determining whether that flip-flop is included as a part of the XOR operation.</em></span><br><br><br>
  
        The multiplier function works by multiplying the value of the flip-flop by an internal P-value, known as the <strong>"feedback coefficient"</strong>. The feedback coefficient, referred to as p<sub>i</sub>, is a value within the multiplier that only has two possible values: <strong>1</strong> if there is a XOR gate, and <strong>0</strong> if there isn't. Mathematically, this means that the feedback coefficient can only be a binary value: <strong>p<sub>i</sub> ‚àà ‚Ñ§<sub>2</sub></strong>.<br><br>
        
        The feedback coefficient is determined by whether the flip-flop actually has an XOR gate connected to it or not. For example, in the given diagram, every flip-flop has a corresponding XOR gate connected to it just above the multiplier, while in the diagram of Rule 32, only the middle flip-flop has an XOR gate.<br><br>
        
        Mathematically, the principal effect of the feedback coefficient lies in how it decides what value is outputted by the multiplier towards the feedback path. Specifically, the feedback coefficient (p<sub>i</sub>) is the determining factor in the multiplier equation: <strong>O = p<sub>i</sub> √ó I</strong>.<br><br>

        <!--I had such a mental block when writing this section here - the words were not forming. white noise solved the issue!!!!-->
        
        'I' refers to the bit <u>inputted</u> into the multiplier by the flip-flop (i.e., its bit-value at that particular clock cycle), and 'O' represents the <u>output</u> of the multiplier into the feedback path. As evident (and as detailed below), whether p<sub>i</sub> is 0 or 1 is the determining factor in whether the input is the same as the output.<br><br>
        
        If <strong>there IS an XOR gate</strong> for that flip-flop, and thus a connection to the feedback path, then the feedback coefficient will equal 1, since the input is equal to the output: <strong>O = p<sub>i</sub> √ó I = I</strong>.<br><br>
                
        If <strong>there's NO XOR gate</strong>, then the feedback coefficient will equal 0, since the output O must be equal to 0 in order for the inputted bit to have no impact on the feedback path. The output O is equal to 0, and since O = p<sub>i</sub> √ó I, and as I is not necessarily 0, then p<sub>i</sub> must equal 0.<br><br>
        
        
        <!--Thought of this metaphor, a useful way of looking at it. reminds me of papers please-->
        <!--Probably one of my favorite paragraphs out of the entire summary. It just wraps up the concept so smoothly.-->
        In this way, the multiplier is like a <strong><em>border checkpoint</em></strong>, and the feedback coefficient is the <strong><em>inspector</em></strong>. If the XOR gate exists for the flip-flop that multiplier is serving, then the bit is granted unimpeded passage into the gate by the feedback coefficient. However, if no XOR gate exists, then the bit is effectively turned away; by altering the bit to 0, it is made irrelevant to the feedback path, since an addition of zero (the <em>additive neutral element</em> as detailed in the "Rules of the Ring" of Subsection II.III) contributes nothing to the end-result bit of the feedback path (that which is inputted into the leftmost flip-flop).<br><br><br>
        
        
        <!--egregious overexplanation - like who cares? 
        Note that although the bit-value of the flip-flop may <em>already</em> be zero, meaning that it will not impact anything regardless of whether it passes through the multiplier unaltered or not, the repeated nature of the LFSR through continual clock cycles gives relevance to the multiplier for that particular flip-flop position - even if the bit-value of the flip-flop is zero at a particular state/clock cycle, it is extremely likely that at another clock cycle the flip-flop will have a value of one, showing the relevance of the multiplier.
        -->
        
        <!--absolute raw brain power. Not joking, I was confused as hell (and sleep-deprived) but starting playing music that cleared up my mental fog like a fan: https://www.youtube.com/watch?v=rpIVQYuLU3Q-->
        For the following formula, you must know two things about S<sub>m</sub>: It is the sum of all of the XOR operations performed before the first clock cycle, i.e. the preloaded bit-value that is ready to be inputted into the first flip-flop after the initialization vector, and it <u><em>doubles</em></u> as the first outbit bit into the keystream that can be computed using the LFSR equation. Every S value before S<sub>m</sub> is part of the initalization vector (as a result of the diagonal rule), which, of course, is composed of non-deterministic seed values which cannot be calculated.<br><br>
        
        Thus, <em>after</em> the first clock cycle, the <em>second</em> sum of every XOR operation performed along the feedback path (which, of course, involves a different set of bits (as a result of the second state) and produces the <em>second</em> bit-value inputted into the first flip-flop) will be S<sub>m+1</sub>, and so on. This formula synthesizes every generalization made throughout the course of this Rule into a cohesive and elegant little package<!--all this trouble, for a childsplay of an equation-->:<br><br><br>
        
        
        <strong><u>Mathematical Definition</u></strong>:<br><br>
        <em>
        (S<sub>i</sub>, P<sub>j</sub>) ‚àà <strong>‚Ñ§</strong><sub>2</sub><br>
        (i, j) ‚àà <strong>‚Ñ§</strong><sub>m</sub>
        </em><br>
        
          $$S_{m+i} \equiv \left( \sum_{j=0}^{m-1} S_{i+j} \times P_{j} \right) \mod 2$$<br>
          
          <strong>m</strong> = The number of flip-flops in the LFSR. This number determines both the length of the state register and the <em>period</em> (see Rule 34) of the output sequence.<br><br>
          
          <strong>i</strong> = The offset in the shift register, i.e., the number bit of the keystream that is being found. This is why it is <em>‚àà <strong>‚Ñ§</strong><sub>m</sub></em> - it can go no greater than m-1.<br><br>
          
          <strong>S<sub>m + i</sub></strong> = The bit inputted into the first flip-flop at the offset i, and outputted into the keystream at the offset m+i. That's the diagonal rule for you.<br><br><!--I lockedtf in and everything clickrf for me. writing tired, 7:39 am-->
          
          <strong>j</strong> = The index variable for each individual flip-flop, each of which has the <em>potential</em> to contribute to the feedback path, as determined by the feedback coefficient.<br><br>
          
          <strong>S<sub>i + j</sub></strong> = The bit held by a particular flip-flop j at a specific offset i in the shift register. This is the value being inputted into the multiplier function from the flip-flop.<br><br>
          
          <strong>P<sub>j</sub></strong> = The feedback coefficient of the multiplier associated with flip-flop j. Either 0 or 1.<br><br>
          
          <strong>mod 2</strong> = The modulus/remainder operator with respect to 2. Numbers can only be 0 or 1 in this reality - see Rule 24 for a full treatise.
        </div><br><br><br><br>
          <!--I am so fu cking proud of this. I am so tired and so proud.-->
	      
	      
	      
	      
    	  
	  
	  
	        <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <u><span class="rule-number"></span></u>.<!--a wonderful milestone in any subject.--></font>
        </strong> The <strong>Period</strong> is the length of the longest string of numbers before repeating in the keystream generated by an LFSR. It is thus also the number of possible offsets a LFSR can have before repeating a single one. For example, in a particular LFSR with 3 flip-flops (specifically the one given in<!-- the LFSR Exposition--> Rule 32), the keystream is as follows:<br><br>
        
          001011100101110010111001011100101...<br><br>
          
          As seen, the keystream is just a string of "0010111" that repeats infinitely, meaning that the LFSR has a period of <strong>7</strong>.<br><br>
        
      	  A simple principle can thus be derived: <strong>The maximum <em><u>possible</u></em> period (or sequence length) generated by an LFSR of degree m is 2<sup>m</sup> - 1.</strong><br><br>
      	  
      	  As soon as a previous bit pattern/sequence (a 'state') is reached, the cycle will repeat itself, forming a '<strong>state loop</strong>'. Only certain feedback configurations (P<sub>m-1</sub>, ..., P<sub>0</sub>) yield maximum length periods, which will be maximum regardless of the initialization vector (!). <!--which is really quite obvious when you think about it; the shift register is going to move through all of the states within its period anyway, so it doesn't matter at all what state the thing starts with-->For any <em>non</em>-maximum-period LFSR<!--with a set number of flip-flops, m, and a given positioning/number of XOR gates--> however, the initalization vector <em>will</em> affect how long the period is, as different initial states will result in state loops of different lengths.<br><br>
      	  
      	  For an example, consider a LFSR with five flip-flops and a non-maximum feedback configuration. With one initialization vector, the LFSR could have its states repeat after only three distinct rows, and for another initialization vector, could have its states repeat after ten distinct rows, all the while having the same feedback configuration. <strong>Different initialization vectors produce different state loops when the LFSR does not have a maximum-length feedback configuration</strong>.<br><br>
      	  <!--could enter into a state loop of only three distinct states-->
      	  
      	  
          This is why the given value is the maximum <em>possible</em> period of an LFSR - only some reach it. Furthermore, the reason for the "- 1" in the equation is because the maximum period incorporates all possible offsets except for one: 000. As detailed in Rule 35, it is impossible for an all-zeroes row to appear in an LFSR, and thus the highest period an LFSR can strive for is 2<sup>m</sup> - 1.<br><br>
          
          There are patterns within the LFSR, specifically that of the positioning of the XOR gates with respect to the degree m, that can be used to determine if an LFSR will produce a maximum-length period or not - see Rule 38 for more information. These patterns require knowledge of the Polynomial Representation of LFSRs - see Rule 37.
          
	       </div><br><br>
          
          
          
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> The only string of bits that can never appear in an LFSR state is straight 0's. Such a thing is only possible if the initial setting is all straight 0's, which is a ridiculous thought not to be entertained.
	      </div><br><br><br>
	      
	      
	      
	      
	      <strong><a href="#PrimitivePolyDef"><span class="mw-headline" id="PrimitivePolyDef">#</span></a> <font color="#006400">Primitive Polynomials</font></strong>: A special type of irreducible polynomial. An <strong>irreducible polynomial</strong> is akin to a "prime" polynomial, with the only factors being 1 and the polynomial itself. While the application of primitive polynomials in Cryptography is fairly extensive (as seen in Rule 36 & Rule 38), a more detailed analysis of them (and the exact difference between them and irreducible polynomials) can be found in Math Rule [[[.
	      
	      <!--when the complete description is added in the math section (however many years from now): Primitive Polynomials are simply irreducible polynomials with the added property of [[[[ - see Math Rule [[[[ for what this entails. For the beginning cryptographer without advanced knowledge of abstract algebra, just know that primitive polynomials can be extracted from tables, such as that given in Rule 38.-->
        <br><br><br>
        
	      
	      
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Types of LFSRs:</strong><br><br>
      	  In practice, there are three types of LFSRs, the properties of which are the result of the feedback coefficients and degree.
      	  
      	  <ol>
      	  
        	  <li><strong>Primitive Polynomial-based</strong>: These LFSRs are composed of primitive polynomials (see definition), and produce a maximum-length period, the only LFSRs to do so.
        	  </li><br>
        	  
        	  <li><strong>Non-Primitive Irreducible Polynomial-based</strong>: Using irreducible polynomials that are not "primitive", these LFSRs produce a period that is totally independent of the initial value/"state" of the register. These algorithms do <strong><u>not</u></strong> produce maximum-length sequences.
        	  </li><br>
        	  
        	  <li><strong>Reducible Polynomial-based:</strong> These LFSRs have a sequence/period <em>dependent</em> on the initial state of the register. Of course, these algorithms can never produce a maximum-length sequence.
        	  </li><br>
      	  
      	  </ol>
      	  
      	  </div>
	      
	      
	      
	      
	      
	    
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Polynomial Representation of LFSRs</strong>:<br><br>
      	  All that is needed to represent a LFSR mathematically (aside from the initialization vector) is the degree m (the number of flip-flops), and the feedback coefficients. These characteristics can be represented in polynomial form as so:<br><br>
      
          <strong>P(x) = x<sup>m</sup> + P<sub>m-1</sub> √ó x<sup>m-1</sup> + ... + P<sub>1</sub> √ó x + P<sub>0</sub></strong><br><br>
          
          <strong>m</strong> = The number of flip-flops. <br>
          <strong>x</strong> = The simple polynomial variable, nothing to be plugged in. The different variables are differentiated by their exponents in the equation.<br>
          <strong>P<sub>m-1</sub></strong> = The feedback coefficient of the leftmost multiplier function in the register. The sequence P<sub>m</sub> to P<sub>0</sub> represents all multiplier functions, left to right. Because it multiplies the variable, if the feedback coefficient for a particular flip-flop is zero (no XOR gate), then that variable is nullified and removed from the polynomial. If the coefficient is one (XOR gate exists), then the variable remains. This is the intuitive genius of polynomial representation.<br><br>
          
          For example: The LFSR depicted in Rule 32 would be represented as x¬≥ + x + 1.<br><br>
          
          Even if there weren't XOR gates in the entire LFSR, <strong>the equation would still be x<sup>m</sup> + 1</strong>, representing the <U>ending</U> and <U>beginning</U> points of feedback path.<br><br>
          
          Note that the number of variables in the polynomial does not represent the number of flip-flops - it represents the number of <strong>connections</strong> to the feedback path. For example, if there are 3 flip-flops in a register, then there are 4 possible connections, of which the leftmost and rightmost are guaranteed (as stated in the paragraph above). The other two connections are the ones with <em>actual</em> multiplier functions that decide whether they have an XOR gate, and thus whether they are a part of the polynomial. The variables absent from the polynomial give as much information as those included.<br><br>

          Depicted in the illustration below are the placements of the polynomial variables in relation to the feedback paths/connections they actually represent. Each middle flip-flop is incorporated into the feedback path (and thus into the polynomial) with its own XOR gate. Any minor confusion over the previous explanations should be resolved by the image below.<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/LFSRPolynomials.png" class="imglink"><img src="/cryptography/img/LFSRPolynomials.png" alt="An illustration of how each variable of an LFSR polynomial accounts for the feedback path connections of an LFSR. The depicted LFSR has three flip-flops and both possible XOR gates, meaning that the polynomial is completely filled." width=72%/></a></div>
  	    <span class="tiny"><em>An illustration of how each variable of an LFSR polynomial accounts for the feedback path connections of an LFSR. The depicted LFSR has three flip-flops and both possible XOR gates, meaning that the polynomial has every variable present.</em></span><br><br><br>
          
          <!-- I cannot fathom how sleep deprived I must have been when I wrote the below paragraph. Reading it after the fact, it is totally incomprehensible apart from the parts that are just restating what I said better previously. Don't type past your bedtime, kids.
          
          What you are really looking at when you see a polynomial expression of an LFSR is the degree of the first term, and all of the terms in between the first term and the last term, because there is always going to be a +1 at the end. Otherwise, the output would not be incorporated into the feedback path, which is utterly preposterous and is never seen in the real world.<br><br>
          -->
          
          There are patterns in LFSR polynomials that can be used to determine whether the LFSR has a maximum-length period or not: see Rule 38.
      	  </div><br><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Deriving Maximum-Length Periods from LFSR Polynomials:</strong><br><br>
    	    <strong>Only LFSRs with primitive polynomials</strong> (see definition) <strong>yield maximum-length sequences.</strong> <br><br>
    
          Below is a table showcasing an example primitive polynomial for each m value 2-128. Note that there are multitudes of primitive polynomials for any given m value, too many to produce a complete list. There are 6.92 √ó 10‚Å∑ primitive polynomials for an LFSR of m 31.<br><br>
          In the table below, take the values as representing the degrees in reverse order: x^0 + x^1 + x^2, for example. This ensures the +1, a necessary component of any LFSR polynomial as explained in Rule 37.<br><br>
          <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/LFSRTable.png" class="imglink"><img src="/cryptography/img/LFSRTable.png" alt="A table showcasing an example primitive polynomial for each m value 2-128." width=78%/></a></div>
    	    <span class="tiny"><em>A table showcasing an example primitive polynomial for each m value 2-128.</em></span>
    
          </div><br><br><br>
	  
	  
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>HOW TO CRACK A LINEAR FEEDBACK SHIFT REGISTER (LFSR):</strong><br><br>
	  
      	  Linear Feedback Shift Register's have many attractive properties, such as relative randomness and extraordinary efficiency - 100 flip-flops, a miniscule amount of space in hardware, produces a period of 2¬π‚Å∞‚Å∞ - 1, for example. However, it fails on the last hurdle towards cryptographically secure generation: <em>unpredictability</em>.<br><br>
      	  
      	  By its very nature, an LFSR is a PRNG, a <u>deterministic</u> means of producing a keystream, thus opening it up to many vulnerabilities that can be exploited. The main principle that must be acknowledged in attempting to 'break' or 'crack' any stream cipher that utilizes an LFSR is as follows:<br><br>
      
          <strong>If an attacker knows (at least) 2m output values of an LFSR, he can recover the entire LFSR configuration, and from there, the <em>plaintext</em>.</strong><br><br><br>
          
          <!--Recall that the LFSR is merely a keystream generation algorithm, providing the keystream to a simple stream cipher. Thus, both the equations of the stream cipher and those specific to the LFSR can be used in cracking it.<br><br>-->   <!--budget cuts, rule is very long and this explanation is kind of obvious.--> 
          
          Oscar must have the following <u>prerequisite knowledge</u> in order to crack the LFSR: Oscar, as always, must know the complete ciphertext string. Furthermore, he must know the degree <em>m</em> of the LFSR, i.e. the number of flip-flops in the register. This is reasonable knowledge to assume in real life, since the specifications of most cryptographic algorithms (including the m value) are made freely available under Kerckhoffs' Principle (Rule 3). Most damningly, he must also know the first few plaintext characters: x<sub>0</sub>, ..., x<sub>2m - 1</sub>. Much in the same fashion as how the Linear Congruential Generator was cracked (see Rule 29), it can be assumed that the header information of the document supplies this plaintext, and thus it is still realistic for that amount of plaintext to be known to the attacker.<br><br>
          
          Given this knowledge, Oscar simply has to follow a 3-step process in order to recover the entire key:<br><br><br>
          
          
          <p style="font-size:118%;"><u><strong>Step 1</strong></u>: </p>
          Utilizing the definition of the encryption function of a stream cipher (Rule 25), the keystream at position i can be isolated:<br><br>
          
          i ‚àà <strong>‚Ñ§</strong><sub>2m</sub><br><br>
          <strong>S<sub>i</sub> ‚â° (x<sub>i</sub> + y<sub>i</sub>) mod 2</strong>.<br><br>
          
          Since Oscar knows the first 2m bits of both the plaintext and ciphertext, he is able to recover the first 2m keystream bits of the LFSR, which is still <u>not enough:</u> the maximum possible period is 2<sup>m</sup> - 1, so there remain a considerable number of keystream bits that need to be recovered before a complete decryption of the plaintext is possible.<br><br><br>
          
          
          <p style="font-size:118%;"><u><strong>Step 2</strong></u>: </p>
          In order to discover the remaining bits, the feedback coefficients of the multiplier functions must be discovered. This is done using the generalized summation equation of the LFSR (Rule 33). Expanding out the summation will produce the following equation:<br><br>
          
          <strong>S<sub>m</sub> ‚â° (S<sub>m-1</sub> √ó P<sub>m-1</sub> + ... + S<sub>0</sub> √ó P<sub>0</sub>) mod 2</strong><br><br>
          
          <!--babytalk, but whatever-->
          Since Oscar conveniently knows the m value, the only unknowns in this equation are every single feedback coefficient. Thus, there are a total of m unknowns that need to be solved for. In order to solve for m unknowns, a system-of-equations type problem, with m equations, must be created:<br><br>
          
          <strong>S<sub>m</sub> ‚â° (S<sub>m-1</sub> √ó P<sub>m-1</sub> + ... + S<sub>0</sub> √ó P<sub>0</sub>) mod 2</strong><br><br>
          
          <strong>S<sub>m+1</sub> ‚â° (S<sub>m</sub> √ó P<sub>m-1</sub> + ... + S<sub>1</sub> √ó P<sub>0</sub>) mod 2</strong><br><br>
          .<br>
          .<br>
          .<Br><br>
          
          <strong>S<sub>2m-1</sub> ‚â° (S<sub>2m-2</sub> √ó P<sub>m-1</sub> + ... + S<sub>m-1</sub> √ó P<sub>0</sub>) mod 2</strong><br><br>
          
          As was done for Linear Congruential Generators, each unknown can easily be solved for by Gaussian Elimination ([[[[[) or Matrix Inversion ([[[[[[[[).<br><br><br>
          
          
          
          <p style="font-size:118%;"><u><strong>Step 3</strong></u>: </p>
          Now that Oscar knows all of the Feedback Coefficients, he can build the LFSR himself.<br><br>
          
          He can determine the initial state using the output bits that are already known (using the Diagonal Rule, see Rule 31), and from there he will be able to compute the full keystream, S<sub>2m+1</sub> and beyond.<br><br>
          
          With the keystream, Oscar will now, of course, be able to recover the full plaintext:<br><br>
          
          <strong>x<sub>i</sub> ‚â° (y<sub>i</sub> + s<sub>i</sub>) mod 2</strong>
      	  </div><br><br>
	  
	  
	  
  	  
  	    </article>
  	    <header class="articleHeader"><hr>
  	      <h3><span class="mw-headline" id="AltSecureStream">III.V Alternate Secure Stream Ciphers.</span></h3>
  	    </header>
  	    <article>
  	    
  	  
      	  <strong><font color="blue"><a href="#ModernCiphers"><span class="mw-headline" id="ModernCiphers">#</span></a> The Development of Modern Stream Ciphers:</font></strong><br><br>
      
          During the 1990s, stream ciphers were a center of attention for many cryptanalysts, who ruthlessly revealed vulnerabilites and weaknesses that opened particular popular ciphers of the time - this would fuel the predominance of block ciphers in modern cryptographic communications. <br><br>As a result, the eSTREAM project was established in 2004 by the "European Network of Excellence in Cryptology" (an E.U. front), which called for the development (and expert selection) of stream ciphers.<br><br> By 2008, several new, highly secure stream ciphers were developed, divided into two main categories/profiles:<br><br>
          
          <strong>1.</strong> Stream ciphers designed for implementation in software with high-volume data transfer requirements. Examples: Salsa20 (see Rule 40) & ChaCha (see Rule [[[[).
          <br><br>
          
          <strong>2.</strong> Stream ciphers designed for hardware implementation, with low power consumption, storage capabilities, and gate counts. Example: Trivium (see Rule [[[[).
          <br><br><br>
  
  	  
      	  <strong><a href="#ARXORDef"><span class="mw-headline" id="ARXORDef">#</span></a> <font color="#006400">Add-Rotate-XOR (ARX) Ciphers</font></strong>: An algorithm in a cryptosystem that only uses additions, rotations, and XOR operations to generate its keystream.
          <br><br><br>
      	  
      	  <strong><a href="#NonceDef"><span class="mw-headline" id="NonceDef">#</span></a> <font color="#006400">"Nonce"</font></strong>: A number used only once.
          <br><br><br>
  	  
  	  
  	      <div class="rule"><strong>
              <a href="#Rule"><span class="hash">#</span></a> 
              <font color="red">C. Rule <span class="rule-number"></span>.</font>
          </strong> <strong>Salsa20:</strong><br><br>

          <strong><u>Mathematical Definition</u></strong>:<br><br>
          
          [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
          
          
          <strong><u>Explanation:</u></strong><br><br>
          
          
          
          
          <strong>"Salsa20"</strong> is a family of profile-1 stream ciphers, developed in 2005. The PRNG utilizes a 32-bit ARX framework, with additional layers of security added through increased 'rounds' of encryption: the base cipher (Salsa20/20) uses 20 ciphers, while reduced-round, faster varients use 12 rounds (Salsa20/12) and 8 rounds (Salsa20/8), respectively.<br><br>
          
          Salsa20/20 (hereafter referred to as "Salsa20") supports key-lengths of either 128 or 256 bits, though 256 is recommended.<br><br>
          
          [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
    
          </div><br><br>
	  
	  
  	      <div class="rule"><strong>
              <a href="#Rule"><span class="hash">#</span></a> 
              <font color="red">C. Rule <span class="rule-number"></span>.</font>
          </strong> [[[[[Reserved for Future Usage. If additional rules are needed, then the <a href="/information/color.html#WoO">WoO system</a> will be used.[[[[[<br><br>
  	  
        	  [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20, ChaCha, and Trivium"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
        	  
        	  </div><br><br>
  	  
  	  
  	      <div class="rule"><strong>
              <a href="#Rule"><span class="hash">#</span></a> 
              <font color="red">C. Rule <span class="rule-number"></span>.</font>
          </strong> [[[[[Reserved for Future Usage. If additional rules are needed, then the <a href="/information/color.html#WoO">WoO system</a> will be used.[[[[[<br><br>
  	  
      	  [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20, ChaCha, and Trivium"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
      	    </div><br><br>
  	    
  	    
  	      <div class="rule"><strong>
              <a href="#Rule"><span class="hash">#</span></a> 
              <font color="red">C. Rule <span class="rule-number"></span>.</font>
          </strong> [[[[[Reserved for Future Usage. If additional rules are needed, then the <a href="/information/color.html#WoO">WoO system</a> will be used.[[[[[<br><br>
  	  
      	  [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20, ChaCha, and Trivium"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
    	    </div><br>
	    
	  
	    </article>
	   </div>
	</div>
	
	<div class="General links">
		links
		<hr>
		<strong>Programming</strong><br>
		<a href="https://www.youtube.com/watch?v=8jLOx1hD3_o">Short C++ Tutorial</a><br>
		<a href="https://codeforces.com/blog/entry/125639">Code</a><a href="https://www.youtube.com/@tmwilliamlin168/videos">forces</a><br>
		<a href="https://www.youtube.com/playlist?list=PLGs0VKk2DiYw-L-RibttcvK-WBZm8WLEP">Arduino Tutorial</a><br>
		<a href="https://www.youtube.com/playlist?list=PLGs0VKk2DiYz8js1SJog21cDhkBqyAhC5">MicroPython</a><br>
		<a href="https://matplotlib.org/cheatsheets/">2D Python Plots</a><br><br>
		<strong>MIDI</strong><br>
		<a href="https://www.anvilstudio.com/">Anvil Studio</a><br>
		<a href="https://meme.institute/gxscc/">GXSCC</a><br><br>
		<strong>Physics</strong><br>
		<a href="https://www.feynmanlectures.caltech.edu/I_toc.html">Feynman Lectures</a><br>
		<a href="https://www.youtube.com/@FlippingPhysics/playlists">Physics Intro.</a><br><br>
		<strong>Aggregators</strong><br>
		<a href="https://news.ycombinator.com/news">Hacker News</a><br>
		<a href="https://webcurios.co.uk/all-curios/">Web Curios</a><br>
		<a href="https://waxy.org/category/links/">Waxy</a><br>
		<hr>
		<a href="https://ocw.mit.edu/" class="imglink"><img src="/_other/ocw_logo_orange.202255b67af1a72a1f52.png" width=90%></a>
		<a href="https://www.eff.org/issues/innovation" class="imglink"><img src="/_other/eff.png" width=90%></a>
		<a href="https://archive.org/donate" class="imglink"><img src="/_other/internetarchive.gif" width=60%></a>
	</div>
      
</div>
      <footer class="site">
      <br>
        <strong><a href="/cryptography/symmetry.html">Symmetric Cryptography</a></strong><br>
        <article><strong><a href="/cryptography/symmetricFull.html">Pt. 1: Intro & Stream Ciphers</a></strong> ‚Üí <strong><a href="/cryptography/symmetricFull2.html">Pt. 2: Block Ciphers</a></strong></article>
        <br>
        <article><strong><a href="/cryptography/symmetric/intro.html">Introductions</a></strong> ‚Üí <strong><a href="/cryptography/symmetric/historical.html">Historical Ciphers & Modular Arithmetic</a></strong> ‚Üí <strong>Stream Ciphers</strong> ‚Üí <strong><a href="/cryptography/symmetric/block.html">Block Ciphers: Intro & DES</a></strong><br> ‚Üí <strong><a href="/cryptography/symmetric/block2.html">Block Ciphers: AES</a></strong><!-- ‚Üí <strong><a href=""></a></strong> ‚Üí <strong><a href=""></a></strong> ‚Üí <strong><a href=""></a></strong> ‚Üí <strong><a href=""></a></strong> ‚Üí <strong><a href=""></a></strong> ‚Üí <strong><a href=""></a></strong> ‚Üí <strong><a href=""></a></strong> ‚Üí <strong><a href=""></a></strong>--></article>
      	<br>
      	<hr>
      	<span class="tiny">Last Change: August 9 2025</span><br>
      	<span class="tiny">Jonathan Lacabe 2026</span><br>
      	<span class="tiny"><a href="mailto:jdlacabe@gmail.com">jdlacabe@gmail.com</a></span><br>
      	<img src="/_other/with_love%20(1).gif" width=9%>
      </footer>
      </div>
   </body>
</html>
