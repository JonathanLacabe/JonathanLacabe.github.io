<!doctype html>
<html>
  <head>
  	<meta charset="UTF-8" />
    <title>Symmetric Cryptography Summary (Part 1)</title>
    <link href="/style.css" rel="stylesheet" />
    <link rel="icon" href="/favicon.ico">
  </head>
<body>
<style>
rainbow {
  margin-top: 0px;
  background: linear-gradient(to right, #ef5350, #f48fb1, #7e57c2, #2196f3, #26c6da, #43a047, #eeff41, #f9a825, #ff5722);
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
}
</style>
      <div class="wrapper">
      
      <header class="site" style="color: green; font-family: arial; line-height: 0em;">                                                                                                                      
<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script type="text/javascript">
  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [["$", "$"], ["\\(", "\\)"]],
    },
    "HTML-CSS": {
      scale: 100, //Scale math to match surrounding text
    },
    displayAlign: "left", //Align equations to the left
  });
</script>

<script>
document.addEventListener("DOMContentLoaded", function (){
    //Loop through Rule containers
    let ruleContainers = document.querySelectorAll(".rules");
    ruleContainers.forEach(container =>{
        //Get starting Rule number, use 1 if unspecified.
        let startNumber = parseInt(container.getAttribute("data-start")) || 1;
        let rules = container.querySelectorAll(".rule");
        rules.forEach((rule, index) =>{
            let ruleNumber = startNumber + index;

            //Assign dynamic id to Rule container -> anchor link targets it
            rule.id = "Rule" + ruleNumber;

            //Update all elements displaying Rule #
            let numberElements = rule.querySelectorAll(".rule-number");
            numberElements.forEach(el => {
                el.textContent = ruleNumber;
            });

            //Update the href to target correct id, while preserving '#'.
            let ruleLink = rule.querySelector("a");
            if(ruleLink){
                ruleLink.href = "#Rule" + ruleNumber;
            }
        });
    });
});
</script>

<img src="/_other/logos/Symmetric_Encryption.png" width=36%><!--ALSO SPRACH ZARATHUSTRA.-->
<hr>
      	<span><em>Art by Shoaib Pasha.</em></span><hr>
      </header>

      <div class="inner">
	<nav>
		<div class="cont">
		  <a href="/index.html">Home</a><br>
		  <a href="/sitemap.txt">Sitemap</a><br>
		  <hr>
		  <a href="/Physics/physics.html">Physics</a><br>
		  <a href="/math/mathematics.html">Math</a><br>
		  <a href="/cryptography/cryptography.html">Crypto.</a><br>
		  <a href="/engineering/electric.html">Electric</a><br><!--It looks better as "Electric", considering Nuclear is without a period as well-->
		  <a href="/astronomy/astronomy.html">Astronomy</a><br>
		  <a href="/engineering/aeronautics.html">Aero.</a><br>
		  <a href="/engineering/nuclear.html">Nuclear</a><br>
		  <hr><!--Internal Pages-->
		  <a href="/information/recentchanges.txt">Recent Changes</a><br>
		  <a href="/information/color.html">Color Code</a><br>
		  <a href="/information/art.html">Logos</a><br>
		  <a href="/information/about.html#FAQ">FAQ</a><br><!--Will link to a section within the about page-->
		  <a href="/information/about.html">About</a><br>
		  <hr><!--All Mirrors-->
		  <a href="https://hkproject.org/">HKProject</a><br>
		  <a href="https://github.com/JonathanLacabe/JonathanLacabe.github.io">GitHub</a><br>
		  <a href="https://humanknowledge.neocities.org/">Neocities</a><br>
		</div>
	</nav>
	
	<div class="content">
	  <header class="articleHeader">
	    <h2>Summary of Symmetric Cryptography, Part 1: Intro & Stream Ciphers.</h2>
	    <!--<h3><em>Theory > Application.</em></h3>-->
	  </header>
	  <hr>
	  <article>
	    <p>This is the first part of my complete notes for Symmetric Cryptography, covering such topics as Keystreams, Modular Arithmetic, Integer Rings, Shift Ciphers, Affine Ciphers, Stream Ciphers, Linear Feedback Shift Registers, and more. <br><br>I color-coded my notes according to their meaning - for a complete reference for each type of note, see <a href="/information/color.html">here</a> (also available in the sidebar). All of the knowledge present in these notes has been filtered through my personal explanations for them, the result of my attempts to understand and study them from my classes and online courses. In the unlikely event there are any egregious errors, contact me at <a href="mailto:jdlacabe@gmail.com">jdlacabe@gmail.com</a>.</p>
	  </article>
	  <article><center><strong><h3>Table Of Contents</h3></strong></center></article>
	  
          <article><center><a href="#Introductions">I. Introductions</a></center></article>
        
      <div class="toc-container">
        <div class="toc-column">
          <a href="#Terminology">I.I Classification & Terminology.</a>
        </div>
        <div class="toc-column">
          <a href="#AnalysisBasics">I.IV Cryptanalysis Basics.</a>
        </div>
        
      </div>
      
      <div class="toc-container">
        <div class="toc-column">
          <a href="#SymmetricBasics">I.II Symmetric Crypto. Basics.</a>
        </div>
        <div class="toc-column">
          <a href="#GenericAttacks">I.V Generic Analytical Attacks.</a>
        </div>
        
      </div>
      
      <div class="toc-container">
        <div class="toc-column">
          <a href="#KeyTerminology">I.III Key Terminology.</a>
        </div>
        <div class="toc-column">
          <!--<a href="#GenericAttacks">I.IV Generic Analytical Attacks.</a>-->
        </div>
        
      </div><br>
      
      
      
      <article><center><a href="#Historical">II. Historical Ciphers & Modular Arithmetic.</a></center></article>
        
      <div class="toc-container">
        <div class="toc-column">
          <a href="#Substitution">II.I Substitution Cipher.</a>
        </div>
        
        <div class="toc-column">
          <a href="#ShiftCipher">II.IV Shift/Caesar Cipher.</a>
        </div>
 
      </div>
      
      
      <div class="toc-container">
        <div class="toc-column">
          <a href="#ModularArithmetic">II.II Modular Arithmetic Basics.</a>
        </div><!---->
        <div class="toc-column">
          <a href="#AffineCipher">II.V Affine Cipher.</a>
        </div>
        
      </div>
      
      <div class="toc-container">
        <div class="toc-column">
          <a href="#IntegerRings">II.III Integer Rings.</a>
        </div><!--
        <div class="toc-column">
          <a href="#ShiftCipher">II.IV Shift/Caesar Cipher.</a>
        </div>-->
        
      </div>
      
      <br>
      
      
      
      <article><center><a href="#StreamCiphers">III. Stream Ciphers.</a></center></article>
        
      <div class="toc-container">
        <div class="toc-column">
          <a href="#StreamIntro">III.I Intro to Stream Ciphers.</a>
        </div>
        <div class="toc-column">
          <a href="#LFSR">III.IV LFSRs.</a>
        </div>
      </div>
      
      <div class="toc-container">
        <div class="toc-column">
          <a href="#RNG">III.II Random Number Generation.</a>
        </div>
        
        <div class="toc-column">
          <a href="#AltSecureStream">III.V Alt. Secure Stream Ciphers.</a>
        </div>
      </div>
      
      <div class="toc-container">
        <div class="toc-column">
          <a href="#LFSRFundamentals">III.III Fundamentals of LFSRs.</a>
        </div>
        
        <div class="toc-column">
          <!--<a href="#AltSecureStream">III.VI Alt. Secure Stream Ciphers.</a>-->
        </div>
      </div>
      
      
      <br>
      
      
      
      <div class="rules" data-start="1">
      
      <header class="articleHeader"><hr>
	    <h2><span class="mw-headline" id="Introductions">I. Introductions</span></h2>
	    <h3><span class="mw-headline" id="Terminology">I.I Classification & Terminology.</span></h3>
	  </header>
	  <article><br>
	  
	    <strong><a href="#Fig1"><span class="mw-headline" id="Fig1">#</span></a> Fig. 1. - Cybersecurity Classification Hierarchy:</strong><br>
	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/cryptog1.png" class="imglink"><img src="/cryptography/img/cryptog1.png" alt="A Classification Hierarchy of the major components of Cryptology. For a further classification of Cryptanalysis, see Rule 7, and III.I for Symmetric Cryptography. The work of the mastermind Jonathan Lacabe himself." width=61%/></a></div>
	    <span class="tiny"><em>A Classification Hierarchy of the major components of Cryptology. For a further classification of Cryptanalysis, see Rule 7, and III.I for Symmetric Cryptography. The work of the mastermind Jonathan Lacabe himself.</em></span><br><br><br> 
	    
	    
	    <strong><a href="#CryptologyDef"><span class="mw-headline" id="CryptologyDef">#</span></a> <font color="#006400">Cryptology/Cybersecurity</font></strong>: IT Security - the protection of digital information against misuse, incorporating technical, organizational, and implementation-specific aspects. This is the modern, digital theater of the much greater field of 'Security'<!--monied elites protection force-->.<br><br>
	    
	    All IT Security follows the <strong>CIA Triad</strong>: <u>Confidentiality</u>, <u>Integrity</u> and <u>Availability</u> of information. Security is largely focused on protecting against attackers, while system safety & reliability is focused on protecting against random technical failures.
      <br><br><br>
      
      <strong><a href="#CryptographyDef"><span class="mw-headline" id="CryptographyDef">#</span></a> <font color="#006400">Cryptography</font></strong>: A sub-field of <em>Cryptology</em>;<br><br>The science of securing communication through encryption, especially against the cryptanalysis<!--chosen over cryptanalytic--> efforts of an adversary. Cryptographic algorithms are the bedrock of all cybersecurity systems - if cybersecurity is a car, then Cryptography is the engine.
      <br><br><br>
      
      <strong><a href="#CryptanalysisDef"><span class="mw-headline" id="CryptanalysisDef">#</span></a> <font color="#006400">Cryptanalysis</font></strong>: A sub-field of <em>Cryptology</em>;<br><br>
      
      The reductive counterpart to Cryptography, the science of 'breaking' encryption and bypassing the cryptographic security. Though it is the medium of hackers and cybercriminals, it is also a serious scientific field for researchers to test the security of <u>cryptosystems</u>, i.e. systems established using Cryptography (see definition). This is the <u>only</u> to absolutely ensure the security of the cryptosystem - remember <a href="https://www.schneier.com/blog/archives/2011/04/schneiers_law.html">Schneier's Law</a>.
      <br><br><br>
      
      <strong><a href="#CryptosystemDef"><span class="mw-headline" id="CryptosystemDef">#</span></a> <font color="#006400">Cryptosystem</font></strong>: An application/implementation of a set of cryptographic algorithms (incorporating encryption, decryption, <!--key generation, -->and other mechanisms).
      <br><br><br>
      
      
      <strong><a href="#SymmetricAlgDef"><span class="mw-headline" id="SymmetricAlgDef">#</span></a> <font color="#006400">Symmetric Algorithms</font></strong>: A sub-field of <em>Cryptography</em>;<br><br>
      
      The classic form of Cryptography - two parties hold a secret key, enabling one party to encrypt a message and the other party to decrypt it. Thus, the same key is used for both encryption and decryption.<br><br>
      
      Until 1976, this was the only form of Cryptography in existence, and describes the basic nature of all historical ciphers (such as the shift/caesar cipher and affine cipher) and Stream Ciphers, Block Ciphers, and DES & AES. Although it is indeed the <em>classic</em> form of Cryptography, it is still highly relevant today, as AES remains an industry standard even <a href="https://eprint.iacr.org/2019/272.pdf">into the quantum age</a>.<br><br>
      
      Hash functions are somewhat similar to symmetric algorithms, though they can be considered an independent, <em>third</em> type of Cryptographic algorithm.
      <br><br><br>
      
      
      <strong><a href="#AsymmetricDef"><span class="mw-headline" id="AsymmetricDef">#</span></a> <font color="#006400">Asymmetric/Public-Key Algorithms</font></strong>: A sub-field of <em>Cryptography</em>;<br><br>
      
      The great cryptographic breakthrough of the <u style="text-decoration:underline dotted" title="For that of the 21st century, see the &ldquo;Post-Quantum Cryptography&rdquo; Subcategory.">20th century</u>, Asymmetric Cryptography (a.k.a. "Public Key Cryptography"<!--a perhaps more descriptive name-->) is the backbone of most modern cryptosystems and is what much of the infrastructure of the Internet (protocols, in particular) is based on.<br><br>
      
      Invented by the Diffie-Hellman team in 1976, Public-Key Cryptography functions by having each party have <strong>TWO</strong> keys, a private key and a public key. <br><br>
      
      For more detail on how these algorithms work, see the "Public-Key Cryptography" Subcategory ([[[[[), but know they are used in a variety of fashions: digital signatures, key establishment/management, and more!
      <br><br><br>
      
      
      <strong><a href="#ProtocolsDef"><span class="mw-headline" id="ProtocolsDef">#</span></a> <font color="#006400">Protocols</font></strong>: A sub-field of <em>Cryptography</em>;<br><br>
      
      Collective cryptographic algorithms that serve a complex security function, like a library of algorithms that work together for a common goal. For example - the Transport Layer Security scheme (TLS) and the Hypertext Transfer Protocol (HTTP) are used in every web browser.<br><br> In the words of Edward Snowden, "[The Internet of Things and countless] protocols have given us the means to digitize and put online damn near everything in the world that we don’t eat, drink, wear, or dwell in." 
      <br><br><br>


      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> In Cryptography, '<strong>Primitives</strong>', '<strong>Ciphers</strong>', and '<strong>Algorithms</strong>' all refer to different parts of the same process: the components of a cryptosystem at different scales, algorithms being the largest scale component and primitives being the smallest.<br><br>
        
        <strong><u>Primitives</u></strong> are the basic cryptographic functions (building blocks of an algorithm), <strong><u>Ciphers</u></strong> are the implementation of an encryption scheme, and <strong><u>Algorithms</u></strong> are the combined procedures of primitives and ciphers to create the greater cryptosystem.<br><br>
        
        For example, a well-formed algorithm may incorporate the AES cipher (see Rule [[[), which uses the key schedule primitive (see Rule 51) to assist in both encrypting and decrypting the data.
      </div><br><br>
      
      
      <strong><a href="#ChannelDef"><span class="mw-headline" id="ChannelDef">#</span></a> <font color="#006400">Channel</font></strong>: A transmission medium for data to pass through. Examples include the Internet, airways, and Wi-Fi. Securing transmitted data from being intercepted, and from being intercepted in any meaningful form, is the goal of Cryptography.
      <br><br><br>
      
      <strong><a href="#HybridSchemeDef"><span class="mw-headline" id="HybridSchemeDef">#</span></a> <font color="#006400">Hybrid Schemes</font></strong>: The combined usage of both asymmetric and symmetric algorithms in a cryptosystem, since both types have their own strengths and weaknesses (See [[[<!--should be a sort of comparison between the two types, something created at the end of public-key Cryptography to round off the two major forms as a whole-->).
      <br><br><br>



    </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="SymmetricBasics">I.II Symmetric Crypto. Basics.</span></h3>
	    </header>
	    <article>
	    
	  
	  <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Symmetric Cryptosystem</strong>:
	  
	  
	    <br><br>The ancient problem presents itself: How can two parties communicate over an <strong>insecure channel</strong> (an '<strong>open channel</strong>') without having their communications intercepted by a third-party?<br><br>

      Say <strong>Alice</strong> and <strong>Bob</strong> connect through the internet (which is an open channel due to the potential of package rerouting/interception) and transfer data. An opponent, <strong>Oscar</strong>, can read their communications by intercepting the data before it reaches Bob.<br><br>

	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/alicebobunsecure.png" class="imglink"><img src="/cryptography/img/alicebobunsecure.png" alt="A diagram showcasing how communications between Alice and Bob, when passing through an insecure channel unencrypted, can be intercepted by the attacker Oscar." width=90%/></a></div>
	    <span class="tiny"><em>A diagram showcasing how communications between Alice and Bob, when passing through an insecure channel unencrypted, can be intercepted by the attacker Oscar.</em></span><br><br> 
	    
	    To stop Oscar from reading the message, an encryption algorithm can be established, converting the plaintext message (x) into a ciphertext message (y), and then sending it through the insecure channel. Oscar would only see a stream of random characters/bits as a result of the encryption. Bob, using a decryption function, would convert the ciphertext back into plaintext, thus completing the data transfer without interception.<br><br>

      In order for Bob to not simply decrypt the ciphertext immediately using the decryption function (which, counterintuitively, should actually be made publicly available - see Rule 3), a <strong>Key</strong> only known to Alice and Bob (sent through a secure, impenetrable channel) must be used as a parameter in both the encryption and decryption functions.<br><br>The key must be inputted into the encryption function to influence the manner in which the plaintext is encrypted into cyphertext. Thus, only with the key will Bob be able to decrypt the Ciphertext. Oscar, who doesn't know the key, will be unable to decrypt the message, even if the decryption algorithm is public.<br><br>

	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/AliceBobSecure.png" class="imglink"><img src="/cryptography/img/AliceBobSecure.png" alt="A diagram showcasing a symmetric cryptosystem, complete with a key sent through a secure channel and encryption/decryption functions." width=90%/></a></div>
	    <span class="tiny"><em>A diagram showcasing a symmetric cryptosystem, complete with a key sent through a secure channel and encryption/decryption functions.</em></span><br><br> 
	    
	    <strong>x</strong> = Plaintext message - the unadulterated, original content of the message.<br><br>

      <strong>y</strong> = Ciphertext, which looks like scrambled characters to an interceptor like Oscar.<br><br>
      
      <strong>e</strong> = Encryption function, a mathematical formula that converts x into y.<br><bR>
      
      <strong>d</strong> = Decryption function, a mathematical formula that converts y into x.<br><br>
      
      <strong>K</strong> = The Key fed into the encryption and decryption functions.<br><br>
      	    
      <strong>|K|, 𝒦</strong> = Keyspace, the total number of possible keys in a cryptosystem. This matters significantly with regard to brute-force Cryptanalysis (see Rule 8), and entails other characteristics detailed in Rule 6.
      	    
      </div><br><br><br>
      
      
      
      
      <div class="rule"><strong>
          <a href="#Rule"><span class="hash">#</span></a> 
          <font color="red">C. Rule <span class="rule-number"></span>.</font>
      </strong> Keeping the encryption/decryption algorithms 'e' and 'd'<!--looks better like this than with ()--> secret, preventing their cryptanalysis by the enemy (known as <strong>Security by Obscurity</strong>), was standard procedure for the ~4000 year history of Cryptography prior to the discovery of public-key Cryptography. However, <strong>the only way of ensuring the security of the algorithms is to make them public so that they can be analyzed by cryptanalysts</strong>.<br><br>


        This is the central principle of a foundational law in Cryptography, postulated in 1883 by Auguste Kerckhoffs:<br><br><br>
        
        <strong>Kerckhoffs' Principle</strong>:<br><br>
        <em>"A cryptosystem should be secure even if the attacker</em> (Oscar)<em> knows all the details of the system, with the exception of the secret key."</em><br><br><br>
        
        
        In Practice: Never use an untested Crypto algorithm! Furthermore, never roll your own crypto!
        </div><br><br><br>
        
        
        <strong><a href="#EndToEndDef"><span class="mw-headline" id="EndToEndDef">#</span></a> <font color="#006400">End-To-End Encryption (E2EE)</font></strong>: A system of encryption widely used in modern communication services (like internet messaging sites), in which all data sent from Alice to Bob (party #1 to party #2) is never decrypted at any point along its route until it reaches Bob. <br><br>
        
        Thus, all parties intercepting/eavesdropping will be unable to read or manipulate the message, even if they control any of the base stations the message goes through.<br><br>
        
        	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/e2eediagram.png" class="imglink"><img src="/cryptography/img/e2eediagram.png" alt="An example of how communications between Alice and Bob would occur under a end-to-end encryption scheme." width=82%/></a></div>
        	    <span class="tiny"><em>An example of how communications between Alice and Bob would occur under a end-to-end encryption scheme.</em></span>
        <br><br><br>
        
      
      
      
      
      
          </article>
    	    <header class="articleHeader"><hr>
    	      <h3><span class="mw-headline" id="KeyTerminology">I.III Key Terminology.</span></h3>
    	    </header>
    	    <article>
      
      <!--Below is a visual representation of what happens when I get confused upon one minor thing, which then leads me down a rabbit hole of further confusion and horror as I realize I had a very tenuous grasp on some of the most fundamental principles underpinning all of the subject I am learning. Thus is the curse of the LCG - literally this entire section was produced as a result of me trying to revise one random RNG Rule, which I also had problems with in the past.-->
      
      <!--quite possibly the hardest I have ever cooked, ever-->
      
      <strong><font color="blue"><a href="#Binary"><span class="mw-headline" id="Binary">#</span></a> Binary:</font></strong><br><br>
        Binary is a crucial element of how most (and practically all modern) cryptosystems work, and several phrases commonly used in cryptographic discussions directly reference this inherent nature. As such, let it be known: all references to 'bits' of any kind are made in regard to 1s and 0s.
        <!--I am not going to teach you what binary is, that is csp crap. I've added it to the prereq's.-->
        
        <br><br><br><br>
        
        
        
        
        
        
        <!--This became so unbelievably bloated I had to make it into not one, but two Rules.-->
        
        <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Bit-Length</strong>:<br><br>

          <strong><u>Mathematical Definition</u></strong>:<br><br>
          
          <em>
          <strong>Value-based Bit-length = ⌊log<sub>2</sub> N⌋ + 1</strong><br>
          <strong>Set-based Bit-length = ⌈log<sub>2</sub> S⌉</strong>
          
          </em><br><br><br>
          
          <strong>N</strong> = Any given number.<br>
          <strong>S</strong> = Any given set.<br><!-- In addition, any number that could be <em>perceived</em> to represent a set, such as modular-->
          <strong>⌊, ⌋</strong> = The Floor function, which returns the greatest integer less than or equal to the given value.<br>
          <strong>⌈, ⌉</strong> = The Ceiling function, which returns the smallest integer larger than or equal to the given value.
          <br><br><br>
          
          <strong><u>Explanation:</u></strong><br><br>
          
          
          
          
        Bit-length is a mathematical term with two definitions and two associated equations, the application of which depends on the context of what you are trying to find the bit-length <em>of</em>. Apart from being able to determine when to apply either definition, bit-length is a remarkably simple concept that hinges on comprehension of binary.<br><br><br>
        
        The first definition is value-based, while the second is set-based.<br><br>
        
        The <strong>bit-length <u><em>of a value</em></u></strong> is the # of bits required to represent a given number.<br>
        The <strong>bit-length <u><em>of a set</em></u></strong> is the # of bits necessary to represent the <em>number of values</em> within the set.<br><br>
        
        While the value-based definition is most popular in computer science (such as in the bit_length() method in Python), the set-based definition is the most popular and relevant in Cryptography. Thus, in cryptographic discussions, it is practically always safe to assume that the term 'bit-length' is being used in regard to the set-based definition.<br><br>
        
        As such, two distinct equations emerge to represent these binary operations. As shown in the mathematical definition, the value-based bit-length uses the <strong><u>floor</u></strong> function while the set-based bit-length uses the <strong><u>ceiling</u></strong> function, rounding downward and upward for any decimal value, respectively. <!-- who cares?: Note that these equations produce the same value whenever the given keyspace is not a power of two.--><br><br><br>
        
        For an example of the two in practice, a keyspace of 2^3 (8 values) would have a <strong><u>value-based bit-length of 4</u></strong>, since 8 is 1000 in binary, and would have a <strong><u>set-based bit-length of 3</u></strong>, since exactly 3 bits would be required to account for every value within the keyspace: 000 through 111 represent a total of 8 values, reaching a highest value of 𝒦-1.<br><br>
        
        With regards to set-based bit-length, this does not mean that each individual value requires three bits to represent it; the value of 1 only "<em>requires</em>" 1 bit to represent it, for example. The set-based bit-length only really means the total number of bits necessary to represent 𝒦-1, which thus accounts for all of the values before it (through the nature of binary representation).<br><br>
        <!--which makes perfect sense for a modular system, which can only go up to the highest number before the modulus.-->
        
        </div><br><br><br>
        
        
        
        
        
        
        
        <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Key-Length</strong>:<br><br>

          <strong><u>Mathematical Definition</u></strong>:<br><br>
          
          <em>
          <strong>Key-length = ⌈log<sub>2</sub> 𝒦⌉</strong>
          
          </em><br><br><br>
          
          <strong>𝒦</strong> = Keyspace, the total number of possible keys in a cryptosystem.<br>
          <strong>⌈, ⌉</strong> = The Ceiling function, which returns the smallest integer larger than or equal to the given value.
          <br><br><br>
          
          <strong><u>Explanation:</u></strong><br><br>
          
          Key-Length is a concept that builds upon the idea of bit-length, which is explained in Rule 4. Comprehension of bit-length (and the different between <em>value-based</em> and <em>set-based</em> bit-length) is prerequisite for understanding key-length.<br><br>
        
          In its essence, Key-length is a narrowed application of <em><u>set-based</u></em> bit-length specific to the bit-length of the <em>key of a cryptosystem</em>. It is identical in every way to the set-based bit-length definition, except for the minute change of "set" to "keyspace":<br><br>
          
          The <strong>bit-length <u><em>of a keyspace</em></u></strong> is the # of bits necessary to represent the <em>number of values</em> within the keyspace. This value is known as the <strong>key-length</strong>.<br><br>
          
          <!--unnecessary over-elaboration: Key-length is like the cryptography-specific version of bit-length, though the more general set-based bit-length does occasionally come up for non-key aspects of cryptosystems - for an advanced example of bit-length being used in a cryptosystem, see Rule 28.-->
          
          <!--hyphen-maxxed sentence:-->
          Set-based bit-length, and its particular use-case of key-length, will appear with some ubiquity in the Cryptographic Summary. Note how key-length is basically just a subtype <!--more specific/narrowed application-->of bit-length, just like how keybits (see definition) are a more specific type of bit. However, they can NOT be used interchangeably, for reasons outlined below.<br><br>
            
          In Cryptography, the key-length is only <strong>relevant/existent</strong> if the cryptosystem uses binary representation, as detailed in Rule 6. The number of bits necessary to represent each value of the keyspace is meaningless if there are no 'bits' involved in the cryptosystem, as is the case for the Shift Cipher (Rule 20), which has a keyspace of 26 but no meaningful key-length. Somewhat ironically, bit-length does not require a bit-based system to have a meaningful result, as it merely denotes the process of converting a value to its binary form.
        
        </div><br><br><br>
        
        
      
      
      
      
      
      <strong><a href="#KeybitsDef"><span class="mw-headline" id="KeybitsDef">#</span></a> <font color="#006400">Keybits</font></strong>: The binary bits in the key used in a cryptosystem. A key-length, for example, is composed of keybits. In Cryptography, a "256-keybit key-length" is regarded as secure against brute-force attacks (see Rule 8).
      <br><br><br><br>
        
        
        
      <strong><a href="#BitsOfEntropyDef"><span class="mw-headline" id="BitsOfEntropyDef">#</span></a> <font color="#006400">Bits of Entropy/Key Entropy</font></strong>: A term frequently used<!--by those who are trying to sound smart by adding extra buzzwords as filler, when they are really just using a madeup-term that has effectively the same meaning as key-length, except now in slightly more obfuscated form to further separate the average reader from the actual information of a scientific article by inventing completely new bs jargon--> in cryptography, essentially just meaning a number that represents the degree of security a cryptosystem has with respect to its keyspace. It has the equation <strong>⌈log<sub>2</sub> 𝒦⌉</strong>, where 𝒦 is the keyspace of a cryptosystem (the number of possible keys). For example, if a cryptosystem has 2^100 keys, then that cryptosystem has 100 bits of entropy.<br><br>
      
      It really is just a term used to flex security against <u>brute-force attacks</u> (Rule 8), not in reference to anything tangible other than the size of the keyspace itself - it is a self-referential term, actively disguising useful information behind additional artificial buzzwords.<!--haters on r/cryptography kept using this term and now anyone who uses it is a fool in my book. (my book being hk).--><br><br>
      
      <!--using 'key-lengths' and 'bit-lengths' with a hyphen to distinguish more clearly from the non-hyphenated keyspace-->
      It happens to share the same equation as the key-length (as detailed in Rule 6 below), but note that "bits of entropy" is not a term chained to any particular requirement and can thus be applied to any cryptosystem, while the concept of a key-length has several prerequisites that limit its usage. This is in spite of the fact that "bits of entropy" uses the word "bit" - it, like bit-length (but unlike key-length, as distinguished in Rule 5), can be reasonably applied in non-bit-based cryptosystems.
      <br><br><br><br>
      
      
      
      
      <!--My greatest masterpiece. The single most important Rule of the entire project - it took an incredible effort to produce and was edited, revised, and labored upon over the course of days, during which the complete basis for understanding cryptography and bits in this summary changed as a result of the complexity and confusion I had while creating it. The curse of the LCG is one of great benevolence.-->
      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong><strong>Keyspace Mathematics</strong>:<br><br>
        In Symmetric Cryptography, there is an inherent relation between the keyspace of a cryptosystem (|K| or 𝒦), and the key-length of the key (L) that the cryptosystem uses (which is dealt with in detail in Rule 5). It is fairly simple and intuitive, but has some key caveats.<br><br>
        
        If the algorithm uses a 168-bit key, then there are 2^168 possible keys. This is because the keyspace is the number of <em>possible values</em> that could be represented by the bits of the key-length - a key-length of 5 would have 32 possible values, i.e. every value between 00000 and 11111. Mathematically, this is represented using either of the following equations:<br><br>
        <strong>𝒦 = 2ᴸ</strong><br>
        <strong>L = ⌈log<sub>2</sub> 𝒦⌉</strong><br><br>
        
        These two equations are equivalent, with the second one derived by taking the log of both sides of the first (uncoincidentally forming <em>the</em> key-length equation as described in Rule 5). The ceiling function (which rounds to the closest <em>greater</em> number) is applied to the logarithm to ensure that the key-length is an integer. Of course, the relation only holds insofar that all keys of length L are valid and equally likely to occur, which rules out any symmetric cryptosystem with selective application of its keys/keybits<!--gives 2012 tumblr vibes idk-->.<br><br><!--I no longer have any examples, because DES turned out to fit the relation perfectly. Perhaps one day I shall return-->
        
        There are some limitations that narrow the applicability of this relation - in effect, it only really applies to <em>modern symmetric</em> cryptosystems (unless specified otherwise, like the aforementioned DES). First, all ciphers that do not explicitly <em>have</em> a key-length, such as those that operate on letters instead of bits (e.g., every historical cipher in Section II), do not qualify. A cipher must structure its keys in the form of <u>binary strings with fixed lengths</u> in order for the relation to be applicable.<br><br>
        
        <!--The professor continued with great emphasis: "-->
        As stated in its definition, the very concept of a "<strong>keybit</strong>" is dependent on the fact that the cipher is using a key made from <em>binary bits</em> - any ciphers that do not meet that requirement are instantly null in regards to the given relation.<br><br>
        
        For example, the Shift Cipher (see Rule 20) has a keyspace of 26, but that in no way means that the "key-length" of the cipher is log<sub>2</sub> 26 (though it will indeed have log<sub>2</sub> 26 "bits of entropy"<!--, as stated in the definition of that term.-->). For non-bit cryptosystems, there is no real key-length, but these ciphers are outdated<!--unc--> nonsense cryptography that are not to be taken seriously anyways<!--just felt like airing that out there. the world needs to know-->.<br><br>
        
        Furthermore, this relation does not hold for asymmetric cryptography: There is a significant difference between symmetric keys and asymmetric keys: a 128-bit symmetric key provides roughly the same security as a 3072-bit RSA (asymmetric algorithm) key. For information as to why this is, see Rule [[[.<!--ended up getting rid of some brackets just to add more brackets. good idea for the future though, to illustrate why this is the way that it is.-->
        
        </div><br><br>
      
      
      
      
        
        
        </article>
  	    <header class="articleHeader"><hr>
  	      <h3><span class="mw-headline" id="AnalysisBasics">I.IV Cryptanalysis Basics.</span></h3>
  	    </header>
  	    <article>
  	    
  	    
	    <strong><a href="#Fig2"><span class="mw-headline" id="Fig2">#</span></a> Fig. 2. - Cybersecurity Classification Hierarchy:</strong><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1"> <a href="/cryptography/img/cryptanhier.png" class="imglink"><img src="/cryptography/img/cryptanhier.png" alt="A Classification hierarchy of Cryptanalysis. There are two main branches of Classical Cryptanalysis, Brute-force and Analytical Cryptanalysis. See Subsection I.I for the full classification and III.I for Symmetric Cryptography." width=66%/></a></div>
        <span class="tiny"><em>A Classification hierarchy of Cryptanalysis. There are two main branches of Classical Cryptanalysis, Brute-force and Analytical Cryptanalysis. See Subsection I.I for the full classification and III.I for Symmetric Cryptography.</em></span><br><br><br>
        
    
      <div class="rule"><strong>
          <a href="#Rule"><span class="hash">#</span></a> 
          <font color="red">C. Rule <span class="rule-number"></span>.</font>
      </strong> There are multitudes of cryptanalysis techniques, and the crucial law is that <strong>if just one attack works, then the entire cryptosystem crumbles and fails, regardless of how secure it is against other attack types</strong>.<br><br>
      
      For example, while a substitution cipher (see Rule 10) may be impenetrable to a brute-force attack (Rule 8) with its 2^88 keyspace, it collapses against letter frequency analysis (also described in Rule 10).<br><br>
      
        In order for a cryptosystem to be considered secure, it must be resistant against every single type of attack. An attacker always looks for the weakest link in the cryptosystem. Thus, in addition to strong algorithms, safeguards against social engineering and implementation attacks (see definitions below) must be instituted.
        </div><br><br>
          
          
	    
	    <strong><a href="#ClassicalCryptanalysisDef"><span class="mw-headline" id="ClassicalCryptanalysisDef">#</span></a> <font color="#006400">Classical Cryptanalysis</font></strong>: A sub-field of <em>Cryptanalysis</em> (see Fig. 2);<br><br>
	    
	    The basic, algorithm-focused approach to cryptanalysis in which you analyze the inputs and outputs to probe a viable attack vector. This is the "<em>real</em>" cryptanalysis in the eyes of the cryptography snobs<!--cryptography snobs been real quiet since this dropped-->, in which you try to poke holes in the design of the cryptosystem itself.
      <br><br><br>
      
      
      <strong><a href="#SocialEngineeringDef"><span class="mw-headline" id="SocialEngineeringDef">#</span></a> <font color="#006400">Social Engineering</font></strong>: A sub-field of <em>Cryptanalysis</em> (see Fig. 2);<br><br>
      
      The process of bypassing the protections of a cryptosystem by going directly after the humans that have access to the secret key. Obtaining the key can range from kidnapping and forcing them to tell the key/password, to a simple phishing scheme over the phone or through email.
      <br><br><br>
      
      
      <strong><a href="#ImplementationAttacksDef"><span class="mw-headline" id="ImplementationAttacksDef">#</span></a> <font color="#006400">Implementation Attacks</font></strong>: A sub-field of <em>Cryptanalysis</em> (see Fig. 2);<br><br>
      
      Extraction of the key through '<strong>side-channel analysis</strong>'. By observing the behavior of the implementation of the cryptosystem in an IC or software, it is possible to deduce important information relating to the key.<br><br>
      
      For example: By looking at the electrical power consumption or electromagnetic radiation of a CPU running a cryptographic algorithm, a <STRONG>signal processing technique</STRONG> can be used to recover the key (see E.E. [[[[[<!--not one hundred percent sure, just certain that I want o have somewhere that foes over this topic. perhaps electric engineering may have something on the subject? in the far future? https://ocw.mit.edu/courses/2-161-signal-processing-continuous-and-discrete-fall-2008/pages/syllabus/-->). The runtime behavior can also indicate information regarding the key, which is why many cryptographers ensure constant runtimes in embedded cryptosystems.<br><br>
      
      These attacks are most relevant when the attacker has physical access to a piece of hardware running the cryptosystem, such as a credit card.
      <br><br><br><br>
	    
	    
	    <strong><a href="#AttackVectorsDef"><span class="mw-headline" id="AttackVectorsDef">#</span></a> <font color="#006400">Attack Vectors</font></strong>: The many possible ways to attack a cryptosystem; the <em>types</em> of cryptanalysis that can be used, including (but not limited to) those shown in Fig. 2.
      <br><br><br>
      
      <strong><a href="#MooresLawDef"><span class="mw-headline" id="MooresLawDef">#</span></a> <font color="#006400">Moore’s Law</font></strong>: The computing power of the strongest computers (e.g., the number of transistors in an integrated circuit) will double every 18-24 months while the price will remain constant. This means that computing power, growing exponentially over time, will continually pose more and more of a threat to modern cryptographic systems and to antiquated ones still in use, as it becomes cheaper and faster to break them.<br><br>
      
      This is especially relevant for cryptanalysis requiring intensive computing power, such as brute-force attacks (see Rule 8 below).
      <br><br><br><br>
      
      
      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Classical Attack #1: Brute-Force Attack/Exhaustive Key search</strong>:<br><br>

      <strong><u>Mathematical Definition</u></strong>:<br><br>
      
      <em>Let (x, y) denote the pair of plaintext and ciphertext, and let K = {k<sub>1</sub> ,..., k<sub>κ</sub> } be the keyspace of all possible keys k<sub>i</sub>. A brute-force attack now checks for every k<sub>i</sub> ∈ K whether d<sub>k<sub>i</sub></sub> == x.<br><br>
      
      If the equality holds, a possible correct key is found; if not, proceed with the next key.
      </em>
      <br><br><br>
      
      <strong><u>Explanation:</u></strong><br><br>
      
      The testing of all possible keys in a given keyspace with the decryption function, to find the key that will produce the plaintext. This is akin to thinking of the cryptosystem as a <strong>black box</strong>, in which the only significant factor to decoding an encrypted message is the number of possible keys the message could have been created with. 
      <br><br>
      
      As shown in the illustration below, different keyspaces take different amounts of time to crack using brute-force. As such, only algorithms with a sufficiently large keyspace can be considered secure against brute-force, though not necessarily against any other form of attack.<br><br>
	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/KeyLength.png" class="imglink"><img src="/cryptography/img/KeyLength.png" alt="A chart of the time it would take to crack keyspaces of various lengths using a brute-force attack." width=67%/></a></div>
	    <span class="tiny"><em>A chart of the time it would take to crack keyspaces of various lengths using a brute-force attack.</em></span><br><br>
	    
	    As of 2024, the largest keyspace that can be searched in a relatively reasonable amount of time is 2^80<!--as stated by Paar in a comment on the 6th lecture, extremely reliable firsthand information-->. However, not all keybits are created equally: a 128-bit symmetric key provides roughly the same security as a 3072-bit RSA (asymmetric algorithm) key, as noted in Rule 6. For why this is, see Rule [[[.<!--Same as from the end of Rule 6.-->

      </div><br><br>
      
      
      
      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Classical Attack #2: Analytical Attacks</strong>:<br><br>

      The intelligent counterpart to 'brute'-force, Analytical Attacks examine the internal characteristics of the encryption function and pick apart weaknesses that could enable reconstruction of the plaintext message, such as <u>Letter Frequency Analysis</u> (for the Substitution Cipher, see Rule 10) and <u>Differential Cryptanalysis</u> (for Block and Stream Ciphers, see Rule [[[[<!--an actual Rule fully going over differential cryptanalysis.-->).<br><br>
      
      There is no 'equation' for Analytical Attacks, because they are specific and unique to every cryptosystem (though some common characteristics can emerge between similar cryptosystems).
      </div><br><br>




    </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="GenericAttacks">I.V Generic Analytical Attacks.</span></h3>
	    </header>
	    <article>

      At a minimum, an attacker will always know the ciphertext. There are four generic types of Analytic Attacks that specify what information the attacker possesses in addition (if anything):<br><br><br>
      
      <strong><a href="#CiphertextOnlyDef"><span class="mw-headline" id="CiphertextOnlyDef">#</span></a> <font color="#006400">Ciphertext-only Attack</font></strong>: An attack in which the adversary only has knows the ciphertext.
      <br><br><br>
      
      <strong><a href="#KnownPlaintextDef"><span class="mw-headline" id="KnownPlaintextDef">#</span></a> <font color="#006400">Known-plaintext Attack</font></strong>: In addition to the ciphertext, the adversary also knows some pieces of the plaintext (e.g., header information of an encrypted file or email).
      <br><br><br>
      
      <strong><a href="#ChosenPlaintextDef"><span class="mw-headline" id="ChosenPlaintextDef">#</span></a> <font color="#006400">Chosen-plaintext Attack</font></strong>: An attack in which the adversary can choose the plaintext that is being encrypted and also has access to the corresponding ciphertext, found through possession of the decryption function (whether aware of its internal workings or not).
      <br><br><br>
      
      <strong><a href="#ChosenCiphertextDef"><span class="mw-headline" id="ChosenCiphertextDef">#</span></a> <font color="#006400">Chosen-ciphertext Attack</font></strong>: An attack in which the adversary can choose ciphertexts and obtain the corresponding plaintexts, the goal being (typically) to recover the secret key.
      <br><br><br>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      

    </article>
	    <header class="articleHeader"><hr><hr>
	    <h2><span class="mw-headline" id="Historical">II. Historical Ciphers & Modular Arithmetic.</span></h2>
	    <h3><span class="mw-headline" id="Substitution">II.I Substitution Cipher.</span></h3>
	  </header>
	  <article>
	  
	  
	    <strong><a href="#HistoricalCipherDef"><span class="mw-headline" id="HistoricalCipherDef">#</span></a> <font color="#006400">Historical Cipher</font></strong>: A cipher that was used before the development of modern Cryptography, operating on letters instead of bits/bytes. Every one of these ciphers is easily crackable, from the Enigma Code to the Caesar Cipher.<br><br>
	    
	    Because these ciphers do not operate on bits (and thus do not have keys structured in the form of binary strings with fixed lengths), the relation between keyspace and keybit-length as detailed in Rule 6 does not apply to these ciphers does not apply to these ciphers.
      <br><br><br>
	    
	    
	    <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Substitution Cipher</strong><br><br>
        A historical cipher, operating purely on letters, in which every plaintext letter is replaced by a fixed ciphertext letter. It is just scrambling the letters, nothing more.<br><br>
        
        The Keyspace is 26!, or 2^88, as each plaintext letter that maps to a ciphertext letter decreases the remaining number of possible letters. Thus, a brute-force attack would be out of the question for modern computers.<br><br>
        
        Since the different letters of the English alphabet have different frequencies of appearance (see the image below), and these frequencies are preserved even after scrambling (just different letters will <em>have</em> the frequencies), <strong>Letter Frequency Analysis</strong> can be conducted as an attack on the substitution cipher, making cracking the cipher rather simple.<br><br>
        
        This is an example of a cipher/algorithm in which an Analytical Attack (see Rule 9) is most effective.<br><br>
	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/English_letter_frequency_(alphabetic).png" class="imglink"><img src="/cryptography/img/English_letter_frequency_(alphabetic).png" alt="A generalized distribution of letters in the english language. In substitution ciphers, the frequencies remain the same, with only the letters that represent them changing. Courtesy of Wikimedia." width=58%/></a></div>
	    <span class="tiny"><em>A generalized distribution of letters in the english language. In substitution ciphers, the frequencies remain the same, with only the letters that represent them changing. Courtesy of <a href="https://commons.wikimedia.org/wiki/File:English_letter_frequency_(alphabetic).svg">Wikimedia</a>.</em></span>
	    
	    </div><br><br>
	    
	    
	    </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="ModularArithmetic">II.II Modular Arithmetic Basics.</span></h3>
	    </header>
	    <article>
	    
	    
	    <strong><a href="#PreferredDef"><span class="mw-headline" id="PreferredDef">#</span></a> <font color="#006400">Preferred</font></strong>: The value that allows for the maximal amount of simplification in a given representation.<!--at least, how I use this word. I just rattled this definition off the top of my head, to define a terminology specific to this project-->
      <br><br><br>
      
	  
	    <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Modular Arithmetic</strong>:<br><br>

        <strong><u>Mathematical Definition</u></strong>:<br><br>
        
          <em>(a, r, m) ∈ <strong>ℤ</strong><br>
          m > 0<br><br>
          If <strong>m|(a − r)</strong>, then <strong>a ≡ r mod m</strong>
          </em><BR><BR><br>
          
          <strong>ℤ</strong> = The set of all integers.<br>
          <strong>a</strong> = The chosen number.<br>
          <strong>r</strong> = The remainder.<br>
          <strong>m</strong> = The modulus, the highest possible number in the set.<br>
          <strong>'mod m'</strong> = The modulus operator / remainder operator, which represents the usage of modular arithmetic, with all numbers represented by their remainder with respect to m.
          <br><br><br>
        
        <strong><u>Explanation:</u></strong><br><br>
        
        Since the bulk of cryptographic computations are performed in finite sets, special mathematical tools are needed. In particular, Modular Arithmetic is the basis for all modern cryptosystems, and many historical ones as well.<br><br>
        
        Modular arithmetic is a system of simplifying a number in terms of a given <strong>modulus</strong>, the highest number in a set. As shown in the mathematical definition, any chosen number greater than the modulus is rewritten using the <strong>modulus operator</strong> (a.k.a. the <strong>remainder operator</strong>) with respect to the difference between the number and any multiple (see Rule 12) of the modulus, known as the <em>remainder</em>.<br><br>
        
        The best example for understanding modular arithmetic is something most are already familiar with: time on a clock. On clocks, the highest number is 12, and going any higher just loops back to the beginning. In effect, a clock is a modular arithmetic system using a set of {1, 2, ... 12} with a modulus of 12. 13 hours, for example, would be represented as <strong>1 mod 12</strong>, using the modulus operator as specified in the mathematical definition.<br><br>
        
        The process of finding the modular equivalent of a number (in relation to an already known modulus/set) is simple: divide the chosen number by the modulus, and find the remainder (see Rule 12). The remainder will then be placed as the coefficient in front of the modulus operator. All numbers smaller than the modulus are rendered ordinarily, without the mod operator. For example, the modular representation of 4 in the clock example (mod 12) is just 4.<br><br>
        
        Using modular representation is a bit jarring at first, as it effectively 'wraps' the chosen number around the modulus, but frequent use (as it is used in practically every cryptosystem) will make it second nature to the beginning cryptographer.
        
        </div><br><br>
        
        <strong><a href="#CyclicShiftDef"><span class="mw-headline" id="CyclicShiftDef">#</span></a> <font color="#006400">Cyclic Shift/Cyclical Shift</font></strong>: A fancy term essentially just denoting the usage of modular arithmetic in a particular context, with sets wrapping around once they reach an overflow value and whatnot.
          <br><br><br>

	  
	  
	    <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Modular Arithmetic: Computation of the Remainder.</strong><br><Br>
	      
        <strong><u>Mathematical Definition</u></strong>:<br><br>
          <em>
          (a, m) ∈ <strong>ℤ</strong><br><br>
          
          <strong>a = (q × m) + r</strong><br>
          Thus, <strong>a - (q × m) = r</strong>
          </em><BR><br><Br>
          
          <strong>ℤ</strong> = The set of all integers.<br>
          <strong>a</strong> = The chosen number.<br>
          <strong>q</strong> = The quotient, which produces a multiple of the modulus.<br>
          <strong>r</strong> = The remainder.<br>
          <strong>m</strong> = The modulus, the highest possible number in the set.<br><br><br>
        
        <strong><u>Explanation:</u></strong><br><br>
        To find the remainder in a modular arithmetic system (see Rule 11) when only the chosen number and the modulus (a and m) are known, there is an exact, algorithmic definition. Note that there are <em><strong>two</strong></em> unknown variables in this equation - the quotient and the remainder (q & r). As such, the quotient will have to be determined first in order to find the remainder.<br><br>
        
        Any integer will work for the quotient (as a result of equivalence classes, which will be discussed later in Rule 13), but the <em>preferred</em> quotient will be the one that produces the <em>preferred multiple</em> (once multiplied with m), which will then produce the <em>smallest positive remainder</em> (known as the <em>preferred</em> remainder).<br><Br>
        
        This is just a complicated way of saying that there is a particular quotient value that, when multiplied by the modulus, will produce <u>a <!--particular-->remainder with the chosen value</u> that will allow for the modular representation (the Rule 11 equation with the modulus operator) to be in its most simplified form. The specificities of how this "preferred muliple" (formed by the quotient and the modulus) functions are elaborated upon below.<br><br><!--rewritten, parts move up and down, excessively belabored. I tried to be as simple and understandable as possible while minimizing bloat, but as usual, the bloat seems to have won.-->
        
        <!--an exceptionally rare triple emphasis on "preferred", with u, strong, and em all tagged simultaneously-->
        The <u><strong><em>preferred</em> multiple</strong></u> of the modulus for finding the remainder is <strong>the greatest multiple lower than the chosen number</strong>, allowing for the remainder to be as small as possible: 0 ≤ r &lt; m. Thus, the preferred multiple is mathematically the greatest (q × m) lower than a, which means finding the correct q given that m is a constant.<br><br>
        
        The difference between the preferred multiple and the chosen number is the <strong>smallest positive remainder</strong>, which is thus the <strong>preferred remainder</strong>.<br><br>
        
        For example, with a modulus of 12, 61 would be represented as 1 mod 12, since 61 has a remainder of 1 in relation to <u>60</u>, the highest multiple of 12 below 61 (meaning that 60 is the preferred multiple). With respect to a clock, this means that 61 hours after 12 A.M. would be either 1 A.M. or 1 P.M., exactly <em>which</em> can be determined by mod 2 of the remainder (0 for A.M.; 1 for P.M.).<!--stroke of genius--><br><br>
        
        As stated before, any quotient/multiple of the modulus will work for the equation (if with a larger remainder) - see Rule 13, Equivalence Classes. The preferred multiple just allows for the most simplified version of a modular representation (see Rule 15), which will be the one used in practical applications of modular arithmetic. This preferred multiple is also the one that would be most easily determined by division, as described in Rule 11.
        
        </div><br><br>
	  
	  
	  
	    <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Equivalence Classes</strong>:<br><br>

        While 12 ≡ 3 mod 9, it is equally true that 12 ≡ 21 mod 9, and that 12 ≡ -6 mod 9. Although these remainders may not be the <em>preferred</em> remainder of 3 (see Rule 12), they all still return true in the Modular Arithmetic formula (see Rule 11):<br><br>
        
        12 ≡ 3 mod 9, 3 is a valid remainder since 9|(12−3)<br>
        12 ≡ 21 mod 9, 21 is a valid remainder since 9|(12−21)<br>
        12 ≡ −6 mod 9, −6 is a valid remainder since 9|(12−(−6))<br><br>
        
        The given remainder values can all be simplified down to their smallest possible positive number using the preferred multiple of the modulus, as detailed in Rule 12. Thus, all of these modular representations are inherently equal as they all have the same 'root' preferred remainder. The set of all remainder values that behave 'equivalently' for a particular modulus form what is known as an <strong>Equivalence Class</strong>, an infinite set/series of values.<br><br>
        
        For 3 mod 9, the equivalence class of r values is an infinite set, a partial series of which is as follows:<br>
        {..., -24, -15, -6, 3, 12, 21, 30, ...}<br><br>
        
        If any of these values were to be substituted in for r (3) in 3 mod 9, it would be equivalent, the same value, because of the mod operator.<!--All of the values behave equivalently modulus 9.--><br><br>
        
        Note: There are 'm' equivalence classes for each possible remainder (0 through m-1), which collectively contain all possible integers. The difference between any two neighboring values in an equivalence class will be the modulus, as shown above.
	  
	    </div><br><br>
	  
	  
	  <div class="rule"><strong>
          <a href="#Rule"><span class="hash">#</span></a> 
          <font color="red">C. Rule <span class="rule-number"></span>.</font>
      </strong> <strong>Modular Reduction</strong>:<br><br>
        Because any value in an equivalence class acts the same with regard to the mod operator of a given modulus, then substitutions can be made in mathematical operations that use the modulus operator, simplifying them.<br><br>

        Take (13 × 16) - 8, with modulus 5. While the full number can be computed (200) and an answer derived from there (0 mod 5), that is lame and time-consuming. A much cooler, faster, 21st century means of solving the problem is to substitute in for each term the simplest member of their respective equivalence classes:<br><br>
        
        13 mod 5 has a remainder of 3, and so 3 is the simplest term.<br>
        16 mod 5 has a remainder of 1, and so 1 is the simplest term.<br>
        8 mod 5 has a remainder of 3, and so 3 is the simplest term.<br><br>
        
        Therefore, the same calculation can be performed with simply (3 × 1) - 3, which returns 0 mod 5, the same answer as before, but found much easier-ly.<br><br><br>
        
        Note that this substitution trick does <u>not</u> extend equally to all mathematical operations. Exponentials, for example, cannot be simplified with the modulus:<br><br>
        For the problem 3⁸ mod 7, the exponent '8' cannot be simplified down to 1 mod 7<!--, and the entire problem to 3 mod 7-->. Exponents simply cannot have the substitution performed, while the base can (as shown in the example below).<br><br>
        For all exponentials, simplification into smaller components (using the 2nd Holy Property of Exponents - see Math Rule 66) must be performed to simplify. For ex.: 3⁸ = (3²)⁴ = (9)⁴ = (2)⁴ = 16 mod 7 = <strong>2 mod 7</strong>, which is the answer.<br><br><br>
        
        <strong>Operations where equivalence class substitutions are allowed:</strong><Br><br>
        Multiplication<br>
        Addition<br>
        Substraction<br><br>
        <strong>Operations where equivalence class substitutions are banned:</strong><br><br>
        Exponentials (for the exponent itself, not including the base)<br>
        Division
      	  
  	  </div><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> When getting a result in modular arithmetic, always simplify down to the smallest positive member of the equivalence class (see Rule 13) for your final answer. Whether for a homework/test answer or for 'in-the-field' cryptography work, it is convention to use the most simplified version of the class.<!--This smallest member is found using the preferred multiple, which is extensively discussed in Rule 12.-->
	      </div><br><br>
	  
	  
	  
	    </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="IntegerRings">II.III Integer Rings.</span></h3>
	    </header>
	    <article>
	    
	    
  	    <strong><a href="#IntegerRingDef"><span class="mw-headline" id="IntegerRingDef">#</span></a> <font color="#006400">Integer Ring</font></strong>: A set of elements which can have basic arithmetic operations performed upon them, such as addition and multiplication, so that the natural properties expected of addition and multiplication all hold. There are ring definitions/interpretations of polynomials, matrixes, and modular arithmetic (see Rule 16). Rings are a fundamental part of Ring Theory, a field of Abstract Algebra (see Math section [[[[[). <!--It will go multivariable -> linear algebra -> abstract algebra, with the harvard lecture series forming the brunt of the final: https://www.youtube.com/watch?v=VdLhQs_y_E8&list=PLelIK3uylPMGzHBuR3hLMHrYfMqWWsmx5&index=2-->
        <br><br><br>
	    
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Algebraic Modular Arithmetic</strong>:<br><br>

          Modular Arithmetic can be defined in the form of an integer ring:<br><br><br>
          <em>
          The integer ring <strong>ℤ</strong><sub>m</sub> consists of the following characteristics:<br><br>
          <strong>1.</strong> The set <strong>ℤ</strong><sub>m</sub> = {0, 1, ..., m-1}<!--this is a perfectly formed sentence, meant to be read outloud--><br><br>
          <strong>2.</strong> Two arithmetic operators, "+" and "×", hold for all (a, b, c, d) ∈ <strong>ℤ</strong><sub>m</sub> such that:<br>
          &nbsp;&nbsp;<strong>i)</strong>&nbsp; a + b ≡ c mod m<br>
          &nbsp;&nbsp;<strong>ii)</strong> a × b ≡ d mod m
          </em><br><br><br>
          
          There are many overshadowing rules that every ring has to fulfill, seen in the section "RULES OF THE RING" below.
	      </div><br><br><br>
	    
	  
	    <div title="You WILL accept these as true. You WON'T try to figure out how they were derived."><strong><font color="blue"><a href="#RingRules"><span class="mw-headline" id="RingRules">#</span></a> <u style="text-decoration:underline dotted">RULES OF THE RING:</u></font></strong></div><br>
        These following rules hold true for all integer rings in general, not just those pertaining to modular arithmetic.<br><br>
      <ol>

        <li> The ring should be closed: if any two numbers from the set are multiplied or added together, the result must be in the ring. This is ensured by the modulus operator, which always pulls the number back into the set to a value below m.</li><br>
        
        <li> Addition and multiplication are associative properties: For all (a, b, c) ∈ <strong>ℤ</strong><sub>m</sub>, a + (b + c) = (a + b) + c, and a × (b × c) = (a × b) × c.</li><br><br><br>
        
        <u><strong>Addition:</strong></u><br><br>
        
        <li> Addition is commutative for all (a, b) ∈ <strong>ℤ</strong><sub>m</sub>: a + b = b + a.</li>
        <br>
        
        <li>There is an <strong>additive neutral element</strong>, 0. For all elements a ∈ <strong>ℤ</strong><sub>m</sub>, it holds that <strong>a + 0 ≡ a mod m</strong>. It is used to define the additive inverse.</li>
        <br>
        <!--ajj- backpack playing in my head all day-->
        
        <li>The <strong>additive inverse</strong> always exists: for any element a in the ring, there is always a negative element '-a' such that <strong>a + (-a) ≡ 0 mod m</strong>, the neutral element.</li>
        <br><br><br>
        
        <u><strong>Multiplication</strong></u>:<br><br>
        
        <li>There is a <strong>multiplicative neutral element</strong>, 1: For all elements a ∈ <strong>ℤ</strong><sub>m</sub>, it holds that <strong>a × 1 ≡ a mod m</strong>. It is used to define the multiplicative inverse.</li><br>
        
        <li>The <strong>Multiplicative Inverse</strong> exists only for <u>some</u> elements: For a ∈ <strong>ℤ</strong>, the inverse a⁻¹ is defined such that <strong>a × a⁻¹ ≡ 1 mod m</strong>. The nature of most inverses and the reasons for their occasional nonexistence are outlined in the Inverse Rules - see Rule 17 & Rule 18.<br><br>
        
        If there exists an inverse for a, then, a rare usage of division in the modular ring becomes possible: the element a⁻¹ can be divided by, as a divisor, since <strong>b/a ≡ b × a⁻¹ mod m</strong>.</li>
        <br>
        
        
        <li> The distributive property holds for all ring operations. For all (a, b, c) ∈ <strong>ℤ</strong><sub>m</sub>, a × (b + c) = (a × b) + (a × c).</li>

      </ol><br><br>

      

	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Multiplicative Inverse Eligibility Test</strong>:<!--eligibility worker reference--><br><br>
        
        To determine if an inverse exists for a specific 'a' of a particular modulus, simply find the gcd (Greatest Common Divisor) of the two values:<br><br>

          If <strong>gcd(a, m) = 1</strong>, then there exists a⁻¹, and a & m are said to be "<strong>relatively prime</strong>", or "<strong>coprime</strong>".<br><br>
          If <strong>gcd(a, m) ≠ 1</strong>, then there does <u>NOT</u> exist a⁻¹.<br><br>
          
          If m is prime, then gcd(a, m) will always equal to 1, for all nonzero 'a' values, and thus every 'a' value will have an inverse in that ring. The inverse of an integer completely depends on the ring, and thus the modulus.

	      </div><br><br><br>
	  
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Application of Multiplicative Inverses</strong>:<br><br>
        
        Finding the <strong></strong>Multiplicative Inverse of 'a' has the following formula (as described in RULE OF THE RING #7):<br><br>

          <strong>a × a⁻¹ ≡ 1 mod m</strong>
          <br><br>
          
          Though the multiplicative inverse of a is literally shown as a⁻¹, it is almost never the actual reciprocal of a. The reason for this is simple: All reciprocals other than -1 and 1 are not integers, and are thus not included in the set (under part 1 of the ring definition given in Rule 16).<br><br>
          
          Take a = 5, for example. The supposed inverse '1/5' is incorrect in any context, because it is not included in the set. A different inverse must be found specific to the modulus. For example, if the modulus were 7, then (as the given values pass the multiplicative eligibility test of Rule 17) the true multiplicative inverse can be found:<br><br>
          <strong>5 × 5⁻¹ ≡ 1 mod 7</strong><br><br>
          <strong>5 × 3 ≡ 1 mod 7</strong><br><br>
          <strong>5⁻¹ = 3</strong><br><br>
          
          As shown<!-- and as described--> above, when used in regards to algebraic rings, the concept of an 'inverse' bears no relation to its common usage in representing reciprocals.<!--unnecessary bloat overexplanation: Instead, it is merely used in rings to represent any value that fulfills the given inverse definition, whether in terms of the additive or multiplicative definitions-->
	      </div><br><br>
	    
	    
	    <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> Always, as a rule of life, write denominators as (x)⁻¹<!--when dealing with division--> (instead of as below a line). With the importance of the inverse operation, it is always critical to recognize all denominators as just being inverses of their values. 1/a = a⁻¹.
	      </div><br><br>
	    
	    
	  
	  </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="ShiftCipher">II.IV Shift/Caesar Cipher.</span></h3>
	    </header>
	    <article>
	    
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Shift Cipher:</strong><br><br>
	  
	  
    	  <strong><u>Mathematical Definition</u></strong>:<br><br>
    	  
    	  <em>
        (x, y, k) ∈ <strong>ℤ</strong><sub>26</sub><br><br>
        <strong>Encryption</strong>: <strong>e<sub>k</sub>(x) ≡ (x + k) mod 26</strong><br><br>
        <strong>Decryption</strong>: <strong>d<sub>k</sub>(y) ≡ (y - k) mod 26</strong>
        </em><br><br><br>
        
        <strong>x</strong> = Plaintext message.<br>
        <strong>y</strong> = Ciphertext.<br>
        <strong>k</strong> = The Key fed into the encryption and decryption functions. Here, it represents the number of times that the characters of the plaintext are shifted rightward, using the alphabet<!--(or whatever)--> as the set. Variations may use an expanded set, including numbers and special characters.<br>
        <strong><strong>ℤ</strong><sub>26</sub></strong> = A ring of the first 26 integers (including 0), matching the 26 characters of the alphabet. See Subsection II.III for an explanation of rings.<br>
        <strong>e<sub>k</sub>(x)</strong> = Encryption function, a mathematical formula that converts x into y.<br>
        <strong>d<sub>k</sub>(y)</strong> = Decryption function, a mathematical formula that converts y into x.<br>
        <strong>mod 26</strong> = The modulus/remainder operator, which represents the usage of modular arithmetic, with all numbers represented by their remainder with respect to 26. Variations may use an expanded set, including numbers or special characters, in which case the '26' would change accordingly.
    	  <br><br><br>
    	  
    	  
    	  <strong><u>Explanation:</u></strong><br><br>
    	  
    	  A simplified form or special case of the Substitution Cipher (Rule 10), the <strong>Shift Cipher</strong> (or <strong>Caesar Cipher</strong>) merely shifts every plaintext letter however many so positions rightward in the alphabet, wrapping around when it reaches the end (modular arithmetic!). This is occasionally known as the "ROT" Cipher (short for "rotate"), and the most well-known example is <a href="https://rot13.com/">ROT13</a>, which shifts rightward precisely halfway through the alphabet.<br><br>
    
        As a generic example, with a key of 1, some shifts would be as follows:<br><br>
        a -> b<br>
        b -> c<br>
        ...<br>
        z -> a<br><br>
        As shown, once the alphabet reaches letter (26 - k) + 1, or the position in the ring <strong>ℤ</strong><sub>26</sub> (26 - k) (since the set begins at 0), the shift returns to the front of the alphabet.<br><br>
        
        It should be obvious to all this is an extremely unsecure cryptosystem, with a keyspace of only 26. It is vulnerable to both letter frequency analysis (previously explained in relation to Substitution Ciphers - see Rule 10) and brute-force attacks (see Rule 8).
        
        </div><br><br><br>
        
        

        <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Vigenère Cipher</strong><br><br>

          <strong><u>Mathematical Definition</u></strong>:<br><br>
          
          <em>
          (x, y, k, l) ∈ <strong>ℤ</strong><sub>26</sub><br><br>
          
          <strong>Encryption</strong>: <strong>e<sub>k</sub>(x) ≡ (x<sub>i</sub> + k<sub>i mod l</sub>) mod 26</strong><br><br>
          
          <strong>Decryption</strong>: <strong>d<sub>k</sub>(y) ≡ (y<sub>i</sub> - k<sub>i mod l</sub>) mod 26</strong>
          
          </em><br><br><br>
          
          <strong>x</strong> = Plaintext message.<br>
          <strong>y</strong> = Ciphertext.<br><br>
          <strong>k</strong> = The Key/codeword fed into the encryption and decryption functions, which, like the plaintext, is a series of letters (represented by their numerical value, 0-25) that are referred to by their i position. The key may have less, more, or the same number of characters as the plaintext (see 'l').<br><br>
          <strong>i</strong> = The position in the string of the plaintext, and regardless of the length of l (as a result of the mod operator), the key.<br><br>
          <strong>mod l</strong> = 'l' represents the length of the codeword. The mod operator functions such that if there are less characters in the codeword than in the plaintext, then the codeword characters will wrap around so that they can continue being used to produce ciphertext indefinitely.<br><br>
          <strong><strong>ℤ</strong><sub>26</sub></strong> = A ring of the first 26 integers (including 0), matching the 26 characters of the alphabet. See Subsection II.III for an explanation of rings.<br><br>
          <strong>e<sub>k</sub>(x)</strong> = Encryption function, a mathematical formula that converts x into y.<br>
          <strong>d<sub>k</sub>(y)</strong> = Decryption function, a mathematical formula that converts y into x.<br>
          <strong>mod 26</strong> = The modulus/remainder operator, which represents the usage of modular arithmetic, with all numbers represented by their remainder with respect to 26.
          
          <br><br><br>
          
          
          <strong><u>Explanation:</u></strong><br><br>
          
          A mere variation of the Shift cipher, in which the shift for each letter is determined by a secret codeword 'c', which has 'l' characters. Each character in the code word c represents a number of shifts rightward according to the numerical value. For example, 'a' would represent a rightward shift of zero places, while 'z' would represent a shift of 25 places.<br><br>
          
          The encryption function works as follows: Each character in the plaintext string 'x' is applied a rightward shift according to its respective letter (identical position) in the key text. This is a <em>cyclic</em> shift (see definition), for if the addition of the key-character value produces a number greater than 26, then the alphabet will wrap around to the beginning. For example, the plaintext character 'z' plus the codeword character 'b' will produce the ciphertext character 'a'. An interesting side-effect of this is that if the keytext is just a string of 'a' ("aaaaaaaa"), then the ciphertext will be identical to the plaintext.<!--idk why I added that little tidbit, I just thought it was sort of neat when I was doing my own little thought experiments on the subject--><br><br>
          
          The decryption function, of course, is just the opposite of the encryption function, moving each character of the ciphertext backward by the value in the positional counterpart of the code word 'c'.<br><br>
          
          Because of the way the equation is written, the key does not necessarily need to have the same number of characters as the plaintext. The mod operator on the 'l', the number of characters in the codeword, causes any short codeword to wrap around to account for any longer plaintext strings. For example, for a plaintext of "lingonberry" and a codeword of "sup", the mod operator would cause the codeword to effectively become "supsupsupsu", accounting for each character of the plaintext. Likewise, any codeward longer than the plaintext has any characters beyond the length of the plaintext ignored.<br><br>
          
          For each value of i within l, the characters of the codeword are mathematically denoted as {c<sub>0</sub>, c<sub>1</sub>, ..., c<sub>l - 1</sub>}, and the keys are similarly represented as {k<sub>0</sub>, k<sub>1</sub>, ..., k<sub>l - 1</sub>}.
          
          
          
          </div><br><br>
	  
	  
	  
	    </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="AffineCipher">II.V Affine Cipher.</span></h3>
	    </header>
	    <article>
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Affine Cipher:</strong><br><br>

          <strong><u>Mathematical Definition</u></strong>:<br><br>
          
          <em>
          (x, y, a, b) ∈ <strong>ℤ</strong><sub>26</sub><br>
          K = (a, b)<br><br>
          <strong>Encryption</strong>: <strong>e<sub>k</sub>(x) ≡ ((a × x) + b) mod 26</strong><br><br>
          <strong>Decryption</strong>: <strong>d<sub>k</sub>(y) ≡ (a⁻¹ × (y - b)) mod 26</strong>
          
          </em><br><br><br>
          
          <strong>x</strong> = Plaintext message.<br>
          <strong>y</strong> = Ciphertext.<br>
          <strong>K</strong> = The key, which has been split into two parts: a and b.<br>
          <strong>a</strong> = The multiplied value of the key. The number of possible 'a' values is limited by the necessity of the inverse (for the decryption function), as explained below.<br>
          <strong>a⁻¹</strong> = The inverse of a, necessary for the decryption function.<br>
          <strong>b</strong> = The "shift parameter" value of the key, used only in addition and subtraction operations. There are 26 possible values for b, explained below.<br>
          <strong><strong>ℤ</strong><sub>26</sub></strong> = A ring of the first 26 integers (including 0), matching the 26 characters of the alphabet. See Subsection II.III for an explanation of rings.<br>
          <strong>e<sub>k</sub>(x)</strong> = Encryption function, a mathematical formula that converts x into y.<br>
          <strong>d<sub>k</sub>(y)</strong> = Decryption function, a mathematical formula that converts y into x.<br>
          <strong>mod 26</strong> = The modulus/remainder operator, which represents the usage of modular arithmetic, with all numbers represented by their remainder with respect to 26.
          
          <br><br><br>
          
          
          <strong><u>Explanation:</u></strong><br><br>
          
          The <strong>Affine Cipher</strong> is an attempted improvement of the shift cipher, done by complicating the encryption function through the addition of multiple parameters. However, it is still extremely easy to break. The affine cipher is performed by splitting the key into two parts:<br><br>
          
          <strong>K = (a, b)</strong><br><br>
          
          The number of possible b values in the system is 26, as it is merely the shift parameter (as shown in the definition equations).<br><br>
          
          The number of possible a values, as a result of the inverse in the decryption function, is limited by the condition explicated in the multiplicative inverse eligibility test of Rule 17, with m being 26: only when gcd(a, 26) = 1 is 'a' an inverse, and thus contributive to the number of possible values. Counting all possible values of a (1, 3, 5, 7, 9, ...), all odd numbers 1-26 other than 13, produces an end result of 12 possible 'a' values.<br><br>
          
          The keyspace, being (#a) × (#b), is therefore 312. This remains very easy to break using a brute-force attack (see Rule 8).<br><br> 
          
          Furthermore, letter frequency also remains preserved (since every instance of a particular plaintext character will be converted into the same corresponding ciphertext character, despite the minute differences in the encryption function), so a letter frequency analysis attack is also applicable.<br><br>
          
          Though multiple encryption (i.e., running the ciphertext produced by encryption function <em>back into</em> the encryption function to encrypt it again) will not increase the security of an affine cipher, it will for other ciphers, such as the Data Encryption Standard (see Rule 48).
          </div><br><br><br>

	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> Note: You can ALWAYS derive the decryption function from the encryption function of basic ciphers/algorithms. Just know that the encryption function is equal to y and the decryption function is equal to x, and you can simply isolate the appropriate variable to find whichever function you wish.<br><br>
        
        In doing so, always recall that dividing by a variable (as can occur when dividing both sides as a part of the isolation process) makes that variable into its inverse, as foretold in the lesson of Rule 19 and as demonstrated in the mathematical definition of Rule 22.<br><br><!--EXTREMELY 2096 wording. This is the writing of the future.-->
        
        Know that when doing any algebra with an encryption/decryption equation, the mod operator will simply remain in place on whichever side it was on originally. The mod can be effectively ignored until the end of the isolation process, with it not playing a part in the moving of variables from side to side and whatnot. It will continue to act upon whichever variables are on its side of the equation.
        </div><br><br>
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  
	  </article>
	    <header class="articleHeader"><hr><hr>
	    <h2><span class="mw-headline" id="StreamCiphers">III. Stream Ciphers.</span></h2>
	    <h3><span class="mw-headline" id="StreamIntro">III.I Introduction to Stream Ciphers.</span></h3>
	  </header>
	  <article><br>

      <strong><a href="#Fig3"><span class="mw-headline" id="Fig3">#</span></a> Fig. 3. - Symmetric Cryptography Hierarchy:</strong><br>
      <div class="image-environment" role="img" aria-labelledby="image-alt-1"> <a href="/cryptography/img/cryptog.png" class="imglink"><img src="/cryptography/img/cryptog.png" alt="A Classification hierarchy of Symmetric Cryptography. There are two major branches of Symmetric Cryptography, Block Ciphers and Stream Ciphers. See Subsection I.I for the full tree, and see Rule 7 for Cryptanalysis." width=58%/></a></div>
	    <span class="tiny"><em>A Classification hierarchy of Symmetric Cryptography. There are two major branches of Symmetric Cryptography, Block Ciphers and Stream Ciphers. See Subsection I.I for the full tree, and see Rule 7 for Cryptanalysis.</em></span><br><br><br><br>
	  
	  
      <div class="rule"><strong>
          <a href="#Rule"><span class="hash">#</span></a> 
          <font color="red">C. Rule <span class="rule-number"></span>.</font>
      </strong> <strong>Modular 2 Operations</strong>:<br><br>
        In cryptography, when considering all of the mathematical operations commonly applied in primitives and ciphers, the <strong>modular 2 operation</strong> carries with it a set of properties and a reputation that makes it unique even within modular arithmetic.<Br><br>
        
        <strong>Mod 2 addition and subtraction are the same operation</strong>. Multiplication complicates things, but in all instances where the mod 2 function is limited to addition or subtraction, the results will be identical no matter which operation is applied.<br><br>
        
        <!--I purposely wrote this section with the sortf profound, "when there comes a time in human history" sorta vibe to it. Earl Sweatshirt - Off Top on repeat.-->
      
        With the smallest possible modulus that allows room for variation in the remainder<!--(since mod 1 produces straight 0s)-->, mod 2 operations are by and large the most popular application of modular arithmetic in cryptography. This is because their restriction of all numbers to be either 0s or 1s (by the very nature of a <em>modular operation</em>, see Rule 11) successfully emulates binary representation, making them extremely useful for bit-based computation (and in particular ciphers that intake streams of data, like stream ciphers (see Rule 25)).<br><br><!--Intake is a verb now. Jonathanization of the english language. 'atleast' and 'eachother' are also words now. -->
        <!--it has assumed a life almost detached from modular arithmetic-->
        
        The modular 2 operation is used so often, it has its own symbol in cryptographic diagrams: <strong>a circle with a cross</strong>. See Rule 25 for an example. In electrical engineering, the mod 2 function is known as the <strong>XOR gate</strong>, a type of binary gate (see E.E. [[[[[), further showcasing the broader importance of modular 2 operations in science as a whole. <br><br>
        
    	  Note that the listed properties do <STRONG>NOT</STRONG> extend to the modulus of any other number - only for two. See the Vigenère Cipher (see Rule 21), which works akin to a stream cipher, for proof using mod 26 (hint: the addition and subtraction operations produce different values).
    	  
    	 </div><br><br><br>
      	 
      	 
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Stream Ciphers</strong><br><br>

      <strong><u>Mathematical Definition</u></strong>:<br><br>
      
      <em>
      (x<sub>i</sub>, y<sub>i</sub>, s<sub>i</sub>) ∈ <strong>ℤ</strong><sub>2</sub><br><br>
      <strong>Encryption</strong>: <strong>e<sub>s<sub>i</sub></sub>(x<sub>i</sub>) ≡ (x<sub>i</sub> + s<sub>i</sub>) mod 2</strong><br><br>
      <strong>Decryption</strong>: <strong>d<sub>s<sub>i</sub></sub>(y<sub>i</sub>) ≡ (y<sub>i</sub> + s<sub>i</sub>) mod 2</strong>
      
      </em><br><br><br>
      
      <strong>x<sub>i</sub></strong> = The Plaintext bit at index i.<br>
      <strong>y<sub>i</sub></strong> = The Ciphertext bit at index i.<br>
      <strong>s<sub>i</sub></strong> = The <strong>"Keystream"</strong> at index i, equivalent to 'k' (as in past ciphers). Here, it is the Key (at index i) fed into the encryption and decryption functions.<br>
      <strong><strong>ℤ</strong><sub>2</sub></strong> = A ring of the first 2 integers: {0, 1}. See Subsection II.III for an explanation of rings.<br>
      <strong>e<sub>s<sub>i</sub></sub>(x<sub>i</sub>)</strong> = Encryption function, a mathematical formula that converts each x bit into a y bit.<br>
      <strong>d<sub>s<sub>i</sub></sub>(y<sub>i</sub>)</strong> = Decryption function, a mathematical formula that converts each y bit into an x bit.<br>
      <strong>mod 2</strong> = The modulus/remainder operator with respect to 2. Numbers can only be 0 or 1 in this reality - see Rule 24 for a full treatise.
      
      <br><br><br>


      <strong><u>Explanation:</u></strong><br><br>
      A cipher that encrypts bits individually, processing one bit after another in a sequence. This is opposed to a Block Cipher (see Section IV), which takes in large numbers of bits all at once.<br><br>
      
      
      Using the modular 2 operation (see Rule 24), the encryption and decryption functions of the basic stream cipher can be depicted as shown in Fig. 4.<br><br>

        The central complexity of the Stream Cipher is the generation of the "Keystream", e.g. the stream of bits with which the plaintext is encrypted. This generation must be performed through <em>Random Numbers</em> - see Rule 26.<br><br>
        
        If the keybit (s<sub>i</sub>) is zero, then the plaintext bit will pass through unchanged, but if the keybit is 1, then the plaintext bit will flip (like binary). Thus, if the keystream (by divine intervention) is straight 0's, then the plaintext will go unencrypted. 
        
        <!--Most beautiful 90 seconds in Cryptography:
        https://youtu.be/AELVJL0axRs?list=PL2jrku-ebl3H50FiEPr4erSJiJHURM9BX&t=1520
        
        the Mozart Piano Concerto #21 Andante of Cryptography lecture segments
        
        -->
	      </div><br><br><br>
	      
	      
	      
	      <strong><a href="#Fig4"><span class="mw-headline" id="Fig4">#</span></a> Fig. 4. - Practical Stream Ciphers:</strong><br>
          <div class="image-environment" role="img" aria-labelledby="image-alt-1"> <a href="/cryptography/img/PracticalStream.png" class="imglink"><img src="/cryptography/img/PracticalStream.png" alt="A diagram of how all practical stream ciphers should function, with the modular 2 addition highlighted and the keystream generator (which varies from cipher to cipher) displayed." width=79%/></a></div>
    	    <span class="tiny"><em>A diagram of how all <em>practical</em> stream ciphers (abiding by the encryption and decryption functions defined in Rule 25) function, with the modular 2 addition highlighted and the keystream generator (which varies from cipher to cipher) displayed. Note that the key distribution is not depicted.</em></span><br><br><br><br>
	      
	  
	  
	      <strong><a href="#KeyStreamDef"><span class="mw-headline" id="KeyStreamDef">#</span></a> <font color="#006400">Keystream</font></strong>: A <u><em>stream</em></u> of characters that is combined with the plaintext to produce the ciphertext in a Stream Cipher, or, in the case of asynchronous stream ciphers, combined with a previous ciphertext to produce a new ciphertext.<br><br>

        The keystream is derived from the <u><em>key</em></u> and the <u><em>seed</em></u>. Generally, the keystream is denoted as "s<sub>i</sub>", while the seed itself is s<sub>0</sub>, the initial position/keybit of the stream from which all recursive stream ciphers evolve from in their encryption functions. Inherently, the number of possible seeds is the same as the <strong>keyspace</strong>, since the number of seeds dictates how many keys there can be.<br><br>
        
        The creation of a keystream (both key and seed) involves random number generators, which are detailed in Subsection III.II. The seed, for example, may be created using an actual True Random Number Generator (see Rule 26), while the rest of the key will be deterministically generated <em>from</em> that seed using a PRNG (also Rule 26).<br><!--I was just like, what the hell do I do with all of these parentheticals that are ruining the flow of the thing? asterixize them, of course!-->
        
        <!--**at least all ciphers that use a PRNG algorithm, like the LCG (see Rule 28).-->
        <br><br><br>
	  
	  
    	  <strong><a href="#SynchronousStreamDef"><span class="mw-headline" id="SynchronousStreamDef">#</span></a> <font color="#006400">Synchronous Stream Cipher</font></strong>: A Stream Cipher in which the keystream depends solely on the key, generated independently of the plaintext or ciphertext. Examples include Salsa20 & ChaCha.
        <br><br><br>
        
    	  
    	  <strong><a href="#AsynchronousStreamDef"><span class="mw-headline" id="AsynchronousStreamDef">#</span></a> <font color="#006400">Asynchronous Stream Cipher</font></strong>: A Stream Cipher in which the keystream depends on the ciphertext in addition to the key - the key generation is reliant on previous ciphertext, making it a risky operation. An example is the Cipher Feedback (CFB) mode, described in Rule [[[.
        <br><br><br>
        
	  
	      
	    </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="RNG">III.II Random Number Generation.</span></h3>
	    </header>
	    <article>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Random Number Generators (RNG)</strong>:<br><br> The means with which a system can generate random numbers, for the purposes of constructing/filling a keystream with random bits, are split into three main mechanisms:<br><br>

        <ol>
          <li> <strong>True Random Number Generators (TRNGs)</strong>: "True" random numbers stem from random physical processes that cannot be reproduced. Such <em>natural</em> sources of entropy include flipping a coin, rolling a die, thermal noise, mouse movement, and keystroke timing.<br><br>
          
          Hardware and cryptographic systems have tried a lot of different techniques over the years to create a TRNG by analyzing/recording internal characteristics of the computer. Most modern CPU's have a TRNG within a TPM  (trusted platform module) on the motherboard.<br><br>
          
          An example of a cipher that <em>completely</em> uses TRNGs (not just for one element like the seed, but for the <u><em>entire keystream</em></u>) is the One Time Pad, detailed in Rule 27.
          
          </li><br><br>
          
          
          <li> <strong>Pseudo Random Number Generators (PRNGs)</strong>: An RNG system that is random, but reproducable. Because PRNG's are computed, they are inherently deterministic processes. Since they are deterministic, Alice and Bob can generate the same keystream independently of one another, only needing to know the initial "seed", which is like the key for the key (see the "Keystream" definition).<br><br>
          
          With respect to Stream Ciphers, another commonly-used term is "<strong>PRBS</strong>" (Pseudo-Random Bit/Binary Sequences), which is just a more stream-specific way of looking at what these generators are actually <em>producing</em>.<br><br>
          
          Often, PRNG's are computed with the following function:<br><br>
          
          <strong> s<sub>i+1</sub> = f(s<sub>i</sub>)</strong><br><br>
          
          <strong>s<sub>0</sub></strong> = The initial seed value, which may be an actual TRNG.<br>
          <strong>f(s<sub>i</sub>)</strong> = The 'randomizer' function, which performs whatever upon the seed
          in order to computationally randomize it.<br><br>
          
          This recursive generation is the form taken by the Linear Congruential Generator, an example of a cryptosystem utilizing a PRNG (see Rule 28). <br><br>
          The rand() function in C is a PRNG and uses a seed of 12345, with the following function as the randomizer: <br>S<sub>i+1</sub> = ((1103515245 × s<sub>i</sub>) + 12345) mod 2³¹.
          </li><br><br>
          
          
          <li><strong>Cryptographically Secure Pseudorandom Number Generators (CSPRNGs/CPRNGs)</strong>: PRNG's that have an additional property: the numbers must be <strong><u>unpredictable</u></strong>.<br><br>
          
          Given n output keybits (s<sub>i</sub>, s<sub>i+1</sub>, ..., s<sub>i+(n-1)</sub>), it is computationally infeasible to construct s<sub>i+n</sub>.<br><br>
          
          While in most applications (read: the world outside cryptography), PRNG systems are perfectly fine and suited to create 'random' numbers for whatever purpose, they form very unsecure cryptosystems due to their inherently deterministic nature, and thus in Cryptography, the additional property of unpredictability is required. An example of a commonly-used CPRNG in the real world is the [[[.
          
          
          </li>
        
        </ol>
        </div><br><br>


        <strong><a href="#UnconditionalSecurityDef"><span class="mw-headline" id="UnconditionalSecurityDef">#</span></a> <font color="#006400">Unconditional Security</font></strong>: A cipher is "unconditionally secure" (or "information-theoretically secure") if it cannot be broken even with <u>infinite</u> computing resources. <br><br>
        
        Even if a key is 2^1000 bits, it would not be considered "unconditionally secure", because 2^1000 computers (a patently <u>not</u> infinite amount of computers) would be able to break the key in one second. This is despite the fact that such levels of computing power will never be realized in human history.<br><br> 
        Thus, though there are very many ciphers that are "practically" secure (forming the backbone of our modern cybersecurity systems), they are not unconditionally secure.
        <br><br><br>
        
        
        <strong><a href="#ComputationalSecurityDef"><span class="mw-headline" id="ComputationalSecurityDef">#</span></a> <font color="#006400">Computational Security</font></strong>: A cryptosystem is computationally secure if the best known algorithm for breaking it requires at least t operations, where 't' is some ridiculous number far beyond the reach of modern brute-force computational abilities.
        <br><br><br>

	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>One Time Pad (OTP)</strong><br><br>
          The <strong>One Time Pad</strong> (also referred to as the "<strong>Vernam cipher</strong>") is an example of a TRNG-based cryptosystem. It is <em>the</em> unconditionally secure, totally unbreakable, perfect encryption algorithm. The OTP is a stream cipher with the following properties:<br><br>
          1) The Keystream bits s<sub>i</sub> must originate from a True Random Number Generator (a 'TRNG', see Rule 26, 1.).<br><br>
          2) Each Keystream bit must be used only once.<br><br>
          
          Knowledge of the Keystream must be exclusively limited to the involved parties, of course. At the end of the data transfer, the party that received the data must destroy the key so that it cannot be used by another party to decrypt the message after the fact. This is the same reason why reusing keys is extremely risky and nullifies the security benefits of the OTP.<br><br>
          
          The security of cryptosystem draws from the fact that, without knowledge of the keystream, even a brute-force attack would be futile, because any two text strings are equally as probable to be a particular word in the plaintext: if a four letter word were to be encrypted, it is equally probable for it to be "when", "stop", or "abcd".<br><br>
          
          There is one fundamental drawback of the OTP, however, that prevents its universal application: since keystream bits cannot be reused, <strong>the key has to be as long as the plaintext</strong>. A 400MB file, 8 bits to the byte, would entail a 3.2GB key. As such, the One Time Pad is not the be-all-end-all of Cryptography (at least in terms of application), and other types of CPRNGS are still relevant.
          </div><br><br><br><br>
          
          
          
          
          
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Linear Congruential Generator (LCG)</strong>:<br><br>

          <strong><u>Mathematical Definition</u></strong>:<br><br>
          
            <em>
            (A, B, i, S<sub>i</sub>) ∈ <strong>ℤ</strong><sub>m</sub><br>
            i > 0<br>
            Key K = (A, B)<Br><br>
            
            <strong>S<sub>i + 1</sub> ≡ ((A × S<sub>i</sub>) + B) mod m</strong>
            
            </em><br><br><br>
            
            <strong>S<sub>0</sub></strong> = The initial seed value, which may have been created using a TRNG. Of course, it is not depicted in the equation as the equation only refers to i > 0. The seed value is exactly ⌈log<sub>2</sub> m⌉ bits long, explained below. <br>
            
            <strong>S<sub>i</sub></strong> = The Keystream at index i, where i > 0. It is exactly ⌈log<sub>2</sub> m⌉ bits long, explained below. <br>
            
            <strong>S<sub>i + 1</sub></strong> = The following value in the keystream, which is recursively calculated using the value of the previous bit in the keystream (along with the key). It is exactly ⌈log<sub>2</sub> m⌉ bits long, explained below.<br>
            
            <strong>A</strong> = The multiplied value of the key. It is exactly ⌈log<sub>2</sub> m⌉ bits long, explained below. <br>
            
            <strong>B</strong> = The "shift parameter" value of the key, only used for the addition operation. It is exactly ⌈log<sub>2</sub> m⌉ bits long, explained below.<br>
            
            <strong><strong>ℤ</strong><sub>m</sub></strong> = A ring of m integers. See Subsection II.III for an explanation of rings.<br>
            
            <strong>mod m</strong> = The modulus/remainder operator, which represents the usage of modular arithmetic, with all numbers represented by their remainder with respect to m.
            <br><br><br>
          
          
          <strong><u>Explanation:</u></strong><br><br>
          
          The LCG is a PRNG-based keystream generator, using the attributes of the key and the seed as its base components. It is an example of a non-cryptographically secure PRNG, the 2nd type of RNG detailed in Rule 26. This makes it more practical a system than the One Time Pad (see Rule 27), but much easier to break (see Rule 29). The keystream is deterministically created using a recursive function originating at S<sub>0</sub> (the seed), which itself may be created using a TRNG.<br><br>
          
          Of course, separate from the nature of the function/equation itself, note that there are no "Encryption" or "Decryption" functions, because the given equation is merely for composing the keystream (PRNG-style - see Rule 26), while the equation for the Stream <em>Cipher</em> itself remains the same (see Rule 25).<br><br>
          
          The Linear Congruential Generator bears many similarities to the Affine Cipher (Rule 22), in particular how the key is split into multiple parameters (in the case of the LCG, the key used to generate the key<em>stream</em>). However, the <em>length</em> of the parameters greatly differs between the two - while affine ciphers have a set, immutable value for their keyspace, LCG variables derive their length from the modulus itself.<!--I left this sentence as essentially a stream-of-consciousness placeholder to revise later, basically just setting down my ideas so I could polish them later, only to find that it exactly conveyed the point I was trying to get across, in pretty good diction as well. Didn't change a word.--><br><br> 

          	Note that because the modulus represents a set/ring, <strong>ℤ</strong><sub>m</sub>, m qualifies for the set-based bit-length (as detailed in Rule 4). As such, the fact that variables A, B, and S<sub>i</sub> are all ⌈log<sub>2</sub> m⌉ bits long means that <strong>they are as long as the bit-length of the modulus</strong>.<br><br>
          
          Of course, since m is not the keyspace, ⌈log<sub>2</sub> m⌉ is only in reference to a set-based bit-length and not to the key-length. As such, no determination regarding the keyspace of the LCG can be made from ⌈log<sub>2</sub> m⌉, as the equation for finding it using a set-based bit-length (as extensively discussed in Rule 6) specifically requires the <em>key-length</em>. As a bit-based cryptosystem, the LCG <em>does</em> have a key-length (considering it literally generates keys), just not one equal to the bit-length of m.<br><br>
          
          <!--essentially an alternate version of the intro to the previous paragraph. the specification as to how the confusion lies in how the keylength equation is used much more than the set-based bit-length one would have to be worked in to make it functional, but the current one is pretty good anyways:
          Thus, the usage of the equation with m in the usual place of the keyspace does <u>not</u> mean that m is literally the keyspace - this is the fool's conclusion from a cursory glance of the equation.-->
          
           ⌈log<sub>2</sub> m⌉, as the set-based bit-length of m, merely represents the total number of bits required to represent a variable who can have any value between 0 and m-1. To say that A, B, and Si all have a length of ⌈log2 m⌉ bits does not mean that they are all the same value, but just that they all use the same number of bits to represent their values. For example, 00001 and 11111 represent different values in binary, but both have a bit-length of 5.<br><br><br>
          
          The exact reasonings behind <em>why</em> each variable has a bit-length of m, and how things like the key-length and keyspace are calculated, are subject to the design choices of the Linear Congruential Generator itself. As LCGs are PRNGs, understanding the intricacies of these design choices and the exact purpose behind each part of this particular system is irrelevant to learning Cryptography.<br><br>
          
          The decisions made in designing this RNG were not made from a cryptographic standpoint, and thus warrant no in-depth analysis as to aspects like key-length and keyspace size, as the LCG will never be used in a cryptographic context.<br><br>
          
          The mathematics behind the logic for the aforementioned calculations are thoroughly complex and higher-level, and to describe them in great detail would serve no purpose in a cryptography-focused course. Rather, LCGs are useful for their discussion of how PRNGs can be cracked relatively easily (see Rule 29).
          
          <!--FINALLY. I had to add three additional Rules and an entire new Subsection to get to this point. In omnia scientia quaerere-->

          
          
          <!--Apparently, these things have the craziest mathematics behind their functioning, for the key-length and keyspace: LCG constraints often force 𝐴 A to lie in the multiplicative group modulo 𝑚 m, whose size is 𝜑 ( 𝑚 ) φ(m) (Euler’s totient).
          
          They are cryptologically insecure anyways, so whatever, but just note that this things are totally complex. Note what Paar said - there is a huge amount of research and textbooks discussing PRNGs for non-cryptographic purposes, but they are all irrelevant because they are not cryptographically secure.-->



        <!--
        not sure if this unfinished paragraph is true or not, can't find any good information about it, and I am not exerting a huge amount of effort into doing so because of how tangential and non-essential this section is to cryptography as a whole. ergo the "this is irrelevant and complicated mathematics" approach to explaining it.
        
        Note that the keyspace of a linear congruential generator is not calculated in the same fashion as an Affine cipher, however; whereas the affine cipher simply multiplied the components of the key (A & B) together to find the keyspace, the LCG (and all other ciphers that use a key to generate a keystream) is a bit more abstracted in its approach - 
        -->
          
          
          
          
          <!--Easily the hardest rule(s) I have had to write so far in Cryptography, 26 & 27. Took several hours of total concentration and thinking power, requiring the rewriting of portions of past rules and definitions as well.-->
          
          <!--note: Several months after making these Rules, while in the revisal process, it was once again this section that had me go back and edit and create a bunch of earlier Rules in order to better explain the key concepts at play here. The curse of the LCG strikes again.-->
	      </div><br><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>HOW TO CRACK A LINEAR CONGRUENTIAL GENERATOR (LCG):</strong><br><br>

        In order to crack a rudimentary LCG system and discover the full keystream to decrypt the system, the attacker only needs to know three characters of the plaintext that were encrypted (along with all of the ciphertext). Generally, in encrypting a document (such as Microsoft Word or Excel), there will be file or protocol header information at the start (like the version number), which will always be the same initial symbols being encrypted. Therefore, knowledge of the attacker of these plaintext characters, in addition to the ciphertext, can be assumed.<br><br>
        
        With knowledge of the LCG key-stream equation, the attacker would know S<sub>0</sub>, S<sub>1</sub>, and S<sub>2</sub> only. There would thus be three unknowns: A, B, and m. However, the set of commonly used m values is relatively small (see <a href="https://en.wikipedia.org/wiki/Linear_congruential_generator#Parameters_in_common_use">list</a>), and so iterating through them using brute-force (once A and B have been discovered) would be very simple: simply calculate the associated keystream for each possible m value, then check each keystream using the stream cipher decryption function (see Rule 25) and the known ciphertext, until the correct keystream (and thus m value) is found. Thus, m is considered one of the known variables.<br><br>
        <!--Since modular arithmetic dictates that all integers must be lower than the modulus (the remainder with respect to the modulus), the attacker can easily determine the modulus of a key generation algorithm by just finding the ciphertext keybit with the highest value and then adding one.-->
        
        The attacker only has to create a system of equations-style problem (using the three known plaintext characters and the ciphertext) in order to isolate A and B, respectively.<br><br>
        S<sub>1</sub> ≡ ((A × S<sub>0</sub>) + B) mod m<br>
        S<sub>2</sub> ≡ ((A × S<sub>1</sub>) + B) mod m<br><br>
        
        <strong>A = ((S<sub>1</sub> - S<sub>2</sub>) × (S<sub>0</sub> - S<sub>1</sub>)⁻¹) mod m</strong><br>
        
        <strong>B = (S<sub>1</sub> - (S<sub>0</sub> × (S<sub>1</sub> - S<sub>2</sub>) × (S<sub>0</sub> - S<sub>1</sub>)⁻¹)) mod m</strong><br><br>
        
        After finding A and B, all that would be left to be done is to brute-force m as previously described, and the system would be cracked. The full plaintext would be able to be decoded since every variable of the LCG would be known.
        
        </div><br><br>
      
      
      
      
      </article>
	    <header class="articleHeader"><hr>
	      <h3><span class="mw-headline" id="LFSRFundamentals">III.III Fundamentals of Linear Feedback Shift Registers.</span></h3>
	    </header>
	    <article>
	    
	    <strong><font color="blue"><a href="#LFSRTerminology"><span class="mw-headline" id="LFSRTerminology">#</span></a> LFSR Terminology:</font></strong><br><br>
      Linear Feedback Shift Registers (LFSRs) are a type of keystream generator, and are fundamentally important primitives that serve as the building blocks of many ciphers. There is a large amount of terminology used with LFSRs that obfuscates the readability and coherency of any text describing them. Worse, some phrases/terms are more selectively applied than others and/or share meanings.<br><br>

      As such, to better adumbrate<!--:^)--> LFSRs to the beginning Cryptographer, all known LFSR-specific terminologies are described in detail within Subsections III.III & III.IV (alongside all prerequisite E.E. knowledge for LFSRs), legible for both straight-through reading (as you would approach a standard textbook) and for the 'ctrl-f'ing Cryptographer who encountered an unfamiliar term in the field. <!--All information is presented assuming knowledge of only the information that was previously explained.-->
      
      <br><br><br>
	  
	    <strong><a href="#CSEDef"><span class="mw-headline" id="CSEDef">#</span></a> <font color="#006400">Clocked Storage Element (CSE)</font></strong>: A storage container that captures information at a specific moment in time, storing it until needed. Think of it like a recording device built into the hardware of the computer, and it captures information at the moment a signal is sent to it (updating to replace whatever information was in it previously).<br><Br><!--completely intuitive explanation that should make sense to anyone without an inkling of e.e. knowledge, I am very proud of this one-->
	    
	    In more explicitly electrical engineering terms (for those more experienced in such regards), CSE's are part of <em>Clocking Subsystems</em> (see E.E. Rule [[[[[) and respond to Clock signals (see E.E. Rule [[[[[).
        <br><br><br><br>
	    
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> A "<strong>Flip-flop</strong>" is a clocked storage element that stores a single bit. There is an input, an output, and a <strong>Clock Input</strong> that determines whether any inputted bit is to be stored or not.<br><br>

        The general symbology used in diagrams for a flip-flop (in which D is the input & Q is the output) is as follows:<br><br>
  	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/D-flip-flop-basics.png" class="imglink"><img src="/cryptography/img/D-flip-flop-basics.png" alt="A diagram of the basic functions of the flip-flop electrical component. D is the input, Q is the output. Ignore the Q with the line for now. Courtesy of buildcircuitelectronics." width=53%/></a></div>
  	    <span class="tiny"><em>A diagram of the basic functions of the flip-flop electrical component. D is the input, Q is the output. Ignore the Q with the line for now ([[[)<!--wherever an explanation for this comes up, whether later on in Cryptgraphy or E.E., reference it here-->. Courtesy of <a href="https://www.build-electronic-circuits.com/d-flip-flop/">buildcircuitelectronics</a>.</em></span><br><br><br>
  
        And here is a diagram showing how the output relies on clock signals to accept an input change, if any:<br><br>
  	    <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/D-type_flip-flop_impulse_diagram.png" class="imglink"><img src="/cryptography/img/D-type_flip-flop_impulse_diagram.png" alt="A diagram detailing how the clock signal will influence what data from the input is stored and produced in the output. As shown, the flip-flop will only store the first event captured in the input when the clock signal becomes active, regardless of whether the input changes while the clock signal is still active. Courtesy of Wikipedia." width=60%/></a></div>
  	    <span class="tiny"><em>A diagram detailing how the clock signal will influence what data from the input is stored and produced in the output. As shown, the flip-flop will only store the first event captured in the input when the clock signal becomes active, regardless of whether the input changes while the clock signal is still active. Courtesy of <a href="https://commons.wikimedia.org/wiki/File:D-type_flip-flop_impulse_diagram.png">Wikipedia</a>.</em></span>
  	  
  	    </div><br><br><br>
  	  
  	    
  	    <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Shift Registers</strong>:<br><br> 
        
        A "shift register" is a concatentation of several individual flip-flops. Each flip-flop has a starting bit-value, which it then uses to send a signal to each following flip-flop until the final one, which will produce each bit of the output. The combined bits taken from the final flip-flop form a keystream, as depicted in the diagram below. The shift register is one half of an LFSR (see Rule 32).<br><br>
  	    
  	    Very important to notice in the progress of the bits of a shift register towards the output, is that there is a distinct pattern that holds for each bit-value (placed below the flip-flops on the diagram), known as the <strong>Diagonal Rule</strong>: each bit-value will be translated diagonally rightward and downward, for as many flip-flops as there are to the right. Note this pattern in the diagram below:<br><Br>
  
        An example of a shift register, with three flip-flops, with every new value sent receiving a clock signal:<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/ShiftRegisterDiag1.png" class="imglink"><img src="/cryptography/img/ShiftRegisterDiag1.png" alt="A shift register, complete with three flip-flops, and a starting value of 1-0-0. Data moves over once, and the Diagonal rule is used to create the new data values for the latter flip-flops." width=53%/></a></div>
  	    <span class="tiny"><em>A shift register, complete with three flip-flops, and a starting value of 1-0-0. Data moves rightward as the result of a clock signal allowing each flip-flop to take in the data of the flip-flop to its left, and the Diagonal rule becomes visible in how the data values effectively move diagonally to the right from their initial position.</em></span>
  	    
  	    </div><br><br>
  	  
  	    
        
        
	  
  	    </article>
  	    <header class="articleHeader"><hr>
  	      <h3><span class="mw-headline" id="LFSR">III.IV Linear Feedback Shift Registers.</span></h3>
  	    </header>
  	    <article>
	      
	      
	      
	      <strong><font color="blue"><a href="#LFSRIntro"><span class="mw-headline" id="LFSRIntro">#</span></a> Introduction to Linear Feedback Shift Registers:</font></strong><br><br>
        There is an inherent relationship between electrical engineering and Cryptography, specifically in how Cryptography developed: in the early days of the development of the Stream Cipher, the goal was to create a 'small' stream cipher, e.g. a stream cipher that could be implemented in hardware without using too much power.<br><br>
        
        Today, all stream ciphers fit one of two categories: ciphers optimized for <strong>software implementation</strong>, and ciphers optimized for <strong>hardware implementation</strong>. A prime example of the latter are "Shift Register-Based Stream Ciphers", in particular shift registers (see Rule 31) with a feedback mechanism, better known as Linear Feedback Shift Registers.
        
        <br><br><br><br>
        
	      
	      
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Linear Feedback Shift Registers</strong>:<br><br>

        <strong><u>Mathematical Definition</u></strong>:<br><br>
        
          <em>
          The equation depends on the specific characteristics of the LFSR. Specifically, the number of flip-flops, the number of mod 2 functions, and which flip-flops have mod 2 functions. The following formula applies to all LFSRs and is fully explained/derived in the LFSR Generalization (see Rule 33):<br><br><!--Looking back, I think I handled the problem of the equation well, since the equation is not explicitly explained or detailed in this Rule. For those wanting a refresher on the concept of the LFSR itself, this Rule is good, for those just needing the equation, this Rule is good, and those seeking to comprehend and understand the equation, this note is here to redirect them to the right place.-->
          
          (S<sub>i</sub>, P<sub>j</sub>) ∈ <strong>ℤ</strong><sub>2</sub><br>
          (i, j) ∈ <strong>ℤ</strong><sub>m</sub>
          </em><br><br>
          
          $$S_{m+i} \equiv \left( \sum_{j=0}^{m-1} S_{i+j} \times P_{j} \right) \mod 2$$<br>
          
          <strong>m</strong> = The number of flip-flops in the LFSR. This number determines both the length of the state register and the <em>period</em> (see Rule 34) of the output sequence.<br><br>
          
          <strong>i</strong> = The offset in the shift register, i.e., the number bit of the keystream that is being found. This is why it is <em>∈ <strong>ℤ</strong><sub>m</sub></em> - it can go no greater than m-1.<br><br>
          
          <strong>S<sub>m + i</sub></strong> = The bit inputted into the first flip-flop at the offset i, and outputted into the keystream at the offset m+i. That's the diagonal rule for you.<br><br><!--I lockedtf in and everything clickrf for me. writing tired, 7:39 am-->
          
          <strong>j</strong> = The index variable for each individual flip-flop, each of which has the <em>potential</em> to contribute to the feedback path, as determined by the feedback coefficient.<br><br>
          
          <strong>S<sub>i + j</sub></strong> = The bit held by a particular flip-flop j at a specific offset i in the shift register. This is the value being inputted into the multiplier function from the flip-flop.<br><br>
          
          <strong>P<sub>j</sub></strong> = The feedback coefficient of the multiplier associated with flip-flop j. Either 0 or 1.<br><br>
          
          <strong>mod 2</strong> = The modulus/remainder operator with respect to 2. Numbers can only be 0 or 1 in this reality - see Rule 24 for a full treatise.
          <br><br><br>
        
        <!--On God this is the best explanation of each variable. Human Knowledge is the greatest learning resource known to mankind, better than Wikipedia, better than any Alien knowledgebase.-->
  
        <strong><u>Explanation:</u></strong><br><br>
        
        Occasionally referred to as cryptographic "<em>linear recurrences</em>" by various demented individuals, <u><strong>Linear Feedback Shift Registers</strong></u> are yet another PRNG-based keystream generator, and are thus crackable with some effort (see Rule 39).<br><br>
        
        However, unlike other PRNGS like Linear Congruential Generators (see Rule 28) which have no function in real cryptography due to their absurd unsecurity, the LFSR finds application in many ciphers due to its usefulness as a <u>primitive</u><!--, a building block-->. These ciphers use multiple LFSRs to achieve greater security: the A51 cipher (see Rule [[[<!--potentially a Rule going over the cipher, or maybe just a detailing later on about how A51 ciphers are standard technology in phones and other technological appliances, if the Rule gets scrapped.-->), for example, consists of 3. This greatly enhances the security of the cipher and validates the usage of LFSRs for legitimate cryptographic purposes (see Rule [[[<!-- ", as a result of how [[[[" and then briefly describe why adding more is so effective, with the Rule going over the entire reason in full detail. potentially some Rule abour a cipher that uses the lfsr multiple times, but if it is super far ahead, then it would still be good to have a little explanation here detailing how adding more lfsrs increases the security by any means-->).<br><br>
        
        LFSRs incorporate a standard Shift Register (as detailed in Rule 31) alongside a <strong>feedback mechanism/path</strong>, generating fresh input for the first flip-flop using some output data. The feedback path extends from the output of the rightmost flip-flop (which, as known from the shift register analysis in Rule 31, is the flip-flop whose bits form the keystream) and inputs into the first flip-flop.<br><br>
        
        Placed along the feedback path are modular 2 addition functions (a.k.a. XOR gates, detailed in Rule 24), which are performed between the bit from the final flip-flop (by virtue of it being the beginning of the feedback path) and <u>atleast</u> one other in the shift register. Multiple XOR-gates can be added along the feedback path to create additional mod 2 operations (inherently meaning mod 2 operations involving the product of <em>another</em> mod 2 operation from earlier along the feedback path), complicating the structure of the LFSR and enraging Oscar.<br><br>
        
        The mod 2 calculation is first performed in the initial state of the shift register (the "<strong>initialization vector</strong>" of the shift register - see the "State" definition), before the first clock cycle, pre-computing the value that will be used as input for the first flip-flop <u>on</u> the first <strong>clock cycle</strong>. Every clock cycle adds another row of bits below the flip-flops, accounting for the clock signals sent to each flip-flop and their subsequent outputs.<br><br>
        
        Once the bit travels all the way through the feedback path, having been XOR'd 1+ times with the bits from various points in the register, it is simply fed into the first flip-flop so that the shift register can have a new input value. The value of the bit inputted into the first flip-flop is the result of the summation of all of the possible XOR operations that could be present in the LFSR.<br><br>
  
  
        Since Shift Registers are an integral component of LFSRs, the Diagonal Rule previously described for Shift Registers (see Rule 31) is retained for the movement of bits within an LFSR, as shown in the diagram below:<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/ShiftRegisterDiag2.png" class="imglink"><img src="/cryptography/img/ShiftRegisterDiag2.png" alt="A Linear Feedback Shift Register, complete with three flip-flops and a full period of values, which compose one complete keystream." width=75%/></a></div>
  	    <span class="tiny"><em>A Linear Feedback Shift Register, complete with three flip-flops and a full period of values, which compose one complete keystream.</em></span><br><br><br>
  
        The specific mathematical formula of the keystream produced by the depicted LFSR is (as a result of the diagonal rule): <strong>S<sub>i+3</sub> ≡ (s<sub>i+1</sub> + s<sub>i</sub>) mod 2</strong>.
        
        
        </div><br><br><br>



        <strong><a href="#FeedbackDef"><span class="mw-headline" id="FeedbackDef">#</span></a> <font color="#006400">Feedback Path/Feedback Mechanism</font></strong>: The path that allows for bits to be inputted back into the Linear Feedback Shift Register using output data, forming the "Linear Feedback" part of the LFSR. The path extends from the output of the rightmost flip-flop and inputs into the first flip-flop.<br><br>
        
          Placed along the feedback path are modular 2 addition functions (a.k.a. XOR gates, detailed in Rule 24), which are performed between the bit from the final flip-flop (by virtue of it being the beginning of the feedback path) and <u>atleast</u> one other in the shift register.
        <br><br><br><br><!--reuses a bit of content from the lfsr Rule itself, but I am looking out for the ctrl-f'ing Cryptographer who wants to read an exact definition and doesn't have time to root through a whole Rule-->
        
        
        
        <strong><a href="#LFSRStateDef"><span class="mw-headline" id="LFSRStateDef">#</span></a> <font color="#006400">State/Offset (in regard to LFSRs)</font></strong>: The bits of the flip-flops at a particular row-position in the shift register. Given knowledge of an LFSR state and the XOR-positions/feedback path, every following row of bits can be determined.<br><Br>
        
        The first state of an LFSR is known as the <strong>Initialization Vector</strong>.<br><Br>
        
         Even without knowledge of the XOR positions, by pure knowledge of the first state, almost every flip-flop bit in the following state (except for the first F.F., the recipient of the input of the feedback state) can be determined, as a result of the <u>diagonal rule</u> of Shift Registers (see Rule 31).
        <br><br><br><br>
        
        
        
        <strong><a href="#TapsDef"><span class="mw-headline" id="TapsDef">#</span></a> <font color="#006400">Taps/Tap Sequences</font></strong>: Know that there are alternate terminologies used in more pretentious and snobbish cryptographic circles. In these contexts, each outputted bit is referred to as a <em><strong>tap</strong></em>, while the full list of taps is known as the <em><strong>tap sequence</strong></em>. In the Summary of Cryptography, for the sake of simplicity, these terms will only be referred to as the "<strong>output bits</strong>" and "<strong>keystream</strong>", respectively.
        <br><br><br><br><br>
        
        
        
        
        <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>LFSR Generalization:</STRONG><br><br> 

        To construct a generalized LFSR so that a general equation can be applied, several new mathematical operations must be introduced.<br><br>
        
        First, the number of flip-flops in the register can be generalized to an arbitrary 'm' value.<br><br>
        
        The second generalization is a bit more complex: Understand that it is possible for any flip-flop in an LFSR to have its bits fed into an XOR gate on the feedback path, and for there to be as many XOR gates as flip-flops (minus one, since the rightmost flip-flops share one). Since every flip-flop can have an XOR gate (and thus be apart of the feedback path), a <strong>multiplier function</strong> (labeled P<sub>0</sub> to P<sub>m-1</sub>) is added along each flip-flop's tentative connection to the feedback path, serving as an intermediary between the flip-flop and any possible XOR gate above on the feedback path. The multiplier essentially acts as an on-or-off switch, activating depending on whether there actually is an XOR gate for that particular flip-flop or not, as detailed below.<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/GeneralizedLFSR.png" class="imglink"><img src="/cryptography/img/GeneralizedLFSR.png" alt="A generalized LFSR, with every possible link between a flip-flop and the feedback path having a multiplier function, serving as the 'switch' determining whether that flip-flop is included as a part of the XOR operation." width=82%/></a></div>
  	    <span class="tiny"><em>A generalized LFSR, with every possible link between a flip-flop and the feedback path having a multiplier function, serving as the 'switch' determining whether that flip-flop is included as a part of the XOR operation.</em></span><br><br><br>
  
        The multiplier function works by multiplying the value of the flip-flop by an internal P-value, known as the <strong>"feedback coefficient"</strong>. The feedback coefficient, referred to as p<sub>i</sub>, is a value within the multiplier that only has two possible values: <strong>1</strong> if there is a XOR gate, and <strong>0</strong> if there isn't. Mathematically, this means that the feedback coefficient can only be a binary value: <strong>p<sub>i</sub> ∈ ℤ<sub>2</sub></strong>.<br><br>
        
        The feedback coefficient is determined by whether the flip-flop actually has an XOR gate connected to it or not. For example, in the given diagram, every flip-flop has a corresponding XOR gate connected to it just above the multiplier, while in the diagram of Rule 32, only the middle flip-flop has an XOR gate.<br><br>
        
        Mathematically, the principal effect of the feedback coefficient lies in how it decides what value is outputted by the multiplier towards the feedback path. Specifically, the feedback coefficient (p<sub>i</sub>) is the determining factor in the multiplier equation: <strong>O = p<sub>i</sub> × I</strong>.<br><br>

        <!--I had such a mental block when writing this section here - the words were not forming. white noise solved the issue!!!!-->
        
        'I' refers to the bit <u>inputted</u> into the multiplier by the flip-flop (i.e., its bit-value at that particular clock cycle), and 'O' represents the <u>output</u> of the multiplier into the feedback path. As evident (and as detailed below), whether p<sub>i</sub> is 0 or 1 is the determining factor in whether the input is the same as the output.<br><br>
        
        If <strong>there IS an XOR gate</strong> for that flip-flop, and thus a connection to the feedback path, then the feedback coefficient will equal 1, since the input is equal to the output: <strong>O = p<sub>i</sub> × I = I</strong>.<br><br>
                
        If <strong>there's NO XOR gate</strong>, then the feedback coefficient will equal 0, since the output O must be equal to 0 in order for the inputted bit to have no impact on the feedback path. The output O is equal to 0, and since O = p<sub>i</sub> × I, and as I is not necessarily 0, then p<sub>i</sub> must equal 0.<br><br>
        
        
        <!--Thought of this metaphor, a useful way of looking at it. reminds me of papers please-->
        <!--Probably one of my favorite paragraphs out of the entire summary. It just wraps up the concept so smoothly.-->
        In this way, the multiplier is like a <strong><em>border checkpoint</em></strong>, and the feedback coefficient is the <strong><em>inspector</em></strong>. If the XOR gate exists for the flip-flop that multiplier is serving, then the bit is granted unimpeded passage into the gate by the feedback coefficient. However, if no XOR gate exists, then the bit is effectively turned away; by altering the bit to 0, it is made irrelevant to the feedback path, since an addition of zero (the <em>additive neutral element</em> as detailed in the "Rules of the Ring" of Subsection II.III) contributes nothing to the end-result bit of the feedback path (that which is inputted into the leftmost flip-flop).<br><br><br>
        
        
        <!--egregious overexplanation - like who cares? 
        Note that although the bit-value of the flip-flop may <em>already</em> be zero, meaning that it will not impact anything regardless of whether it passes through the multiplier unaltered or not, the repeated nature of the LFSR through continual clock cycles gives relevance to the multiplier for that particular flip-flop position - even if the bit-value of the flip-flop is zero at a particular state/clock cycle, it is extremely likely that at another clock cycle the flip-flop will have a value of one, showing the relevance of the multiplier.
        -->
        
        <!--absolute raw brain power. Not joking, I was confused as hell (and sleep-deprived) but starting playing music that cleared up my mental fog like a fan: https://www.youtube.com/watch?v=rpIVQYuLU3Q-->
        For the following formula, you must know two things about S<sub>m</sub>: It is the sum of all of the XOR operations performed before the first clock cycle, i.e. the preloaded bit-value that is ready to be inputted into the first flip-flop after the initialization vector, and it <u><em>doubles</em></u> as the first outbit bit into the keystream that can be computed using the LFSR equation. Every S value before S<sub>m</sub> is part of the initalization vector (as a result of the diagonal rule), which, of course, is composed of non-deterministic seed values which cannot be calculated.<br><br>
        
        Thus, <em>after</em> the first clock cycle, the <em>second</em> sum of every XOR operation performed along the feedback path (which, of course, involves a different set of bits (as a result of the second state) and produces the <em>second</em> bit-value inputted into the first flip-flop) will be S<sub>m+1</sub>, and so on. This formula synthesizes every generalization made throughout the course of this Rule into a cohesive and elegant little package<!--all this trouble, for a childsplay of an equation-->:<br><br><br>
        
        
        <strong><u>Mathematical Definition</u></strong>:<br><br>
        <em>
        (S<sub>i</sub>, P<sub>j</sub>) ∈ <strong>ℤ</strong><sub>2</sub><br>
        (i, j) ∈ <strong>ℤ</strong><sub>m</sub>
        </em><br>
        
          $$S_{m+i} \equiv \left( \sum_{j=0}^{m-1} S_{i+j} \times P_{j} \right) \mod 2$$<br>
          
          <strong>m</strong> = The number of flip-flops in the LFSR. This number determines both the length of the state register and the <em>period</em> (see Rule 34) of the output sequence.<br><br>
          
          <strong>i</strong> = The offset in the shift register, i.e., the number bit of the keystream that is being found. This is why it is <em>∈ <strong>ℤ</strong><sub>m</sub></em> - it can go no greater than m-1.<br><br>
          
          <strong>S<sub>m + i</sub></strong> = The bit inputted into the first flip-flop at the offset i, and outputted into the keystream at the offset m+i. That's the diagonal rule for you.<br><br><!--I lockedtf in and everything clickrf for me. writing tired, 7:39 am-->
          
          <strong>j</strong> = The index variable for each individual flip-flop, each of which has the <em>potential</em> to contribute to the feedback path, as determined by the feedback coefficient.<br><br>
          
          <strong>S<sub>i + j</sub></strong> = The bit held by a particular flip-flop j at a specific offset i in the shift register. This is the value being inputted into the multiplier function from the flip-flop.<br><br>
          
          <strong>P<sub>j</sub></strong> = The feedback coefficient of the multiplier associated with flip-flop j. Either 0 or 1.<br><br>
          
          <strong>mod 2</strong> = The modulus/remainder operator with respect to 2. Numbers can only be 0 or 1 in this reality - see Rule 24 for a full treatise.
        </div><br><br><br><br>
          <!--I am so fu cking proud of this. I am so tired and so proud.-->
	      
	      
	      
	      
    	  
	  
	  
	        <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <u><span class="rule-number"></span></u>.<!--a wonderful milestone in any subject.--></font>
        </strong> The <strong>Period</strong> is the length of the longest string of numbers before repeating in the keystream generated by an LFSR. It is thus also the number of possible offsets a LFSR can have before repeating a single one. For example, in a particular LFSR with 3 flip-flops (specifically the one given in<!-- the LFSR Exposition--> Rule 32), the keystream is as follows:<br><br>
        
          001011100101110010111001011100101...<br><br>
          
          As seen, the keystream is just a string of "0010111" that repeats infinitely, meaning that the LFSR has a period of <strong>7</strong>.<br><br>
        
      	  A simple principle can thus be derived: <strong>The maximum <em><u>possible</u></em> period (or sequence length) generated by an LFSR of degree m is 2<sup>m</sup> - 1.</strong><br><br>
      	  
      	  As soon as a previous bit pattern/sequence (a 'state') is reached, the cycle will repeat itself, forming a '<strong>state loop</strong>'. Only certain feedback configurations (P<sub>m-1</sub>, ..., P<sub>0</sub>) yield maximum length periods, which will be maximum regardless of the initialization vector (!). <!--which is really quite obvious when you think about it; the shift register is going to move through all of the states within its period anyway, so it doesn't matter at all what state the thing starts with-->For any <em>non</em>-maximum-period LFSR<!--with a set number of flip-flops, m, and a given positioning/number of XOR gates--> however, the initalization vector <em>will</em> affect how long the period is, as different initial states will result in state loops of different lengths.<br><br>
      	  
      	  For an example, consider a LFSR with five flip-flops and a non-maximum feedback configuration. With one initialization vector, the LFSR could have its states repeat after only three distinct rows, and for another initialization vector, could have its states repeat after ten distinct rows, all the while having the same feedback configuration. <strong>Different initialization vectors produce different state loops when the LFSR does not have a maximum-length feedback configuration</strong>.<br><br>
      	  <!--could enter into a state loop of only three distinct states-->
      	  
      	  
          This is why the given value is the maximum <em>possible</em> period of an LFSR - only some reach it. Furthermore, the reason for the "- 1" in the equation is because the maximum period incorporates all possible offsets except for one: 000. As detailed in Rule 35, it is impossible for an all-zeroes row to appear in an LFSR, and thus the highest period an LFSR can strive for is 2<sup>m</sup> - 1.<br><br>
          
          There are patterns within the LFSR, specifically that of the positioning of the XOR gates with respect to the degree m, that can be used to determine if an LFSR will produce a maximum-length period or not - see Rule 38 for more information. These patterns require knowledge of the Polynomial Representation of LFSRs - see Rule 37.
          
	       </div><br><br>
          
          
          
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> The only string of bits that can never appear in an LFSR state is straight 0's. Such a thing is only possible if the initial setting is all straight 0's, which is a ridiculous thought not to be entertained.
	      </div><br><br><br>
	      
	      
	      
	      
	      <strong><a href="#PrimitivePolyDef"><span class="mw-headline" id="PrimitivePolyDef">#</span></a> <font color="#006400">Primitive Polynomials</font></strong>: A special type of irreducible polynomial. An <strong>irreducible polynomial</strong> is akin to a "prime" polynomial, with the only factors being 1 and the polynomial itself. While the application of primitive polynomials in Cryptography is fairly extensive (as seen in Rule 36 & Rule 38), a more detailed analysis of them (and the exact difference between them and irreducible polynomials) can be found in Math Rule [[[.
	      
	      <!--when the complete description is added in the math section (however many years from now): Primitive Polynomials are simply irreducible polynomials with the added property of [[[[ - see Math Rule [[[[ for what this entails. For the beginning cryptographer without advanced knowledge of abstract algebra, just know that primitive polynomials can be extracted from tables, such as that given in Rule 38.-->
        <br><br><br>
        
	      
	      
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Types of LFSRs:</strong><br><br>
      	  In practice, there are three types of LFSRs, the properties of which are the result of the feedback coefficients and degree.
      	  
      	  <ol>
      	  
        	  <li><strong>Primitive Polynomial-based</strong>: These LFSRs are composed of primitive polynomials (see definition), and produce a maximum-length period, the only LFSRs to do so.
        	  </li><br>
        	  
        	  <li><strong>Non-Primitive Irreducible Polynomial-based</strong>: Using irreducible polynomials that are not "primitive", these LFSRs produce a period that is totally independent of the initial value/"state" of the register. These algorithms do <strong><u>not</u></strong> produce maximum-length sequences.
        	  </li><br>
        	  
        	  <li><strong>Reducible Polynomial-based:</strong> These LFSRs have a sequence/period <em>dependent</em> on the initial state of the register. Of course, these algorithms can never produce a maximum-length sequence.
        	  </li><br>
      	  
      	  </ol>
      	  
      	  </div>
	      
	      
	      
	      
	      
	    
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Polynomial Representation of LFSRs</strong>:<br><br>
      	  All that is needed to represent a LFSR mathematically (aside from the initialization vector) is the degree m (the number of flip-flops), and the feedback coefficients. These characteristics can be represented in polynomial form as so:<br><br>
      
          <strong>P(x) = x<sup>m</sup> + P<sub>m-1</sub> × x<sup>m-1</sup> + ... + P<sub>1</sub> × x + P<sub>0</sub></strong><br><br>
          
          <strong>m</strong> = The number of flip-flops. <br>
          <strong>x</strong> = The simple polynomial variable, nothing to be plugged in. The different variables are differentiated by their exponents in the equation.<br>
          <strong>P<sub>m-1</sub></strong> = The feedback coefficient of the leftmost multiplier function in the register. The sequence P<sub>m</sub> to P<sub>0</sub> represents all multiplier functions, left to right. Because it multiplies the variable, if the feedback coefficient for a particular flip-flop is zero (no XOR gate), then that variable is nullified and removed from the polynomial. If the coefficient is one (XOR gate exists), then the variable remains. This is the intuitive genius of polynomial representation.<br><br>
          
          For example: The LFSR depicted in Rule 32 would be represented as x³ + x + 1.<br><br>
          
          Even if there weren't XOR gates in the entire LFSR, <strong>the equation would still be x<sup>m</sup> + 1</strong>, representing the <U>ending</U> and <U>beginning</U> points of feedback path.<br><br>
          
          Note that the number of variables in the polynomial does not represent the number of flip-flops - it represents the number of <strong>connections</strong> to the feedback path. For example, if there are 3 flip-flops in a register, then there are 4 possible connections, of which the leftmost and rightmost are guaranteed (as stated in the paragraph above). The other two connections are the ones with <em>actual</em> multiplier functions that decide whether they have an XOR gate, and thus whether they are a part of the polynomial. The variables absent from the polynomial give as much information as those included.<br><br>

          Depicted in the illustration below are the placements of the polynomial variables in relation to the feedback paths/connections they actually represent. Each middle flip-flop is incorporated into the feedback path (and thus into the polynomial) with its own XOR gate. Any minor confusion over the previous explanations should be resolved by the image below.<br><br>
        <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/LFSRPolynomials.png" class="imglink"><img src="/cryptography/img/LFSRPolynomials.png" alt="An illustration of how each variable of an LFSR polynomial accounts for the feedback path connections of an LFSR. The depicted LFSR has three flip-flops and both possible XOR gates, meaning that the polynomial is completely filled." width=72%/></a></div>
  	    <span class="tiny"><em>An illustration of how each variable of an LFSR polynomial accounts for the feedback path connections of an LFSR. The depicted LFSR has three flip-flops and both possible XOR gates, meaning that the polynomial has every variable present.</em></span><br><br><br>
          
          <!-- I cannot fathom how sleep deprived I must have been when I wrote the below paragraph. Reading it after the fact, it is totally incomprehensible apart from the parts that are just restating what I said better previously. Don't type past your bedtime, kids.
          
          What you are really looking at when you see a polynomial expression of an LFSR is the degree of the first term, and all of the terms in between the first term and the last term, because there is always going to be a +1 at the end. Otherwise, the output would not be incorporated into the feedback path, which is utterly preposterous and is never seen in the real world.<br><br>
          -->
          
          There are patterns in LFSR polynomials that can be used to determine whether the LFSR has a maximum-length period or not: see Rule 38.
      	  </div><br><br><br>
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>Deriving Maximum-Length Periods from LFSR Polynomials:</strong><br><br>
    	    <strong>Only LFSRs with primitive polynomials</strong> (see definition) <strong>yield maximum-length sequences.</strong> <br><br>
    
          Below is a table showcasing an example primitive polynomial for each m value 2-128. Note that there are multitudes of primitive polynomials for any given m value, too many to produce a complete list. There are 6.92 × 10⁷ primitive polynomials for an LFSR of m 31.<br><br>
          In the table below, take the values as representing the degrees in reverse order: x^0 + x^1 + x^2, for example. This ensures the +1, a necessary component of any LFSR polynomial as explained in Rule 37.<br><br>
          <div class="image-environment" role="img" aria-labelledby="image-alt-1">  <a href="/cryptography/img/LFSRTable.png" class="imglink"><img src="/cryptography/img/LFSRTable.png" alt="A table showcasing an example primitive polynomial for each m value 2-128." width=78%/></a></div>
    	    <span class="tiny"><em>A table showcasing an example primitive polynomial for each m value 2-128.</em></span>
    
          </div><br><br><br>
	  
	  
	  
	  
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> <strong>HOW TO CRACK A LINEAR FEEDBACK SHIFT REGISTER (LFSR):</strong><br><br>
	  
      	  Linear Feedback Shift Register's have many attractive properties, such as relative randomness and extraordinary efficiency - 100 flip-flops, a miniscule amount of space in hardware, produces a period of 2¹⁰⁰ - 1, for example. However, it fails on the last hurdle towards cryptographically secure generation: <em>unpredictability</em>.<br><br>
      	  
      	  By its very nature, an LFSR is a PRNG, a <u>deterministic</u> means of producing a keystream, thus opening it up to many vulnerabilities that can be exploited. The main principle that must be acknowledged in attempting to 'break' or 'crack' any stream cipher that utilizes an LFSR is as follows:<br><br>
      
          <strong>If an attacker knows (at least) 2m output values of an LFSR, he can recover the entire LFSR configuration, and from there, the <em>plaintext</em>.</strong><br><br><br>
          
          <!--Recall that the LFSR is merely a keystream generation algorithm, providing the keystream to a simple stream cipher. Thus, both the equations of the stream cipher and those specific to the LFSR can be used in cracking it.<br><br>-->   <!--budget cuts, rule is very long and this explanation is kind of obvious.--> 
          
          Oscar must have the following <u>prerequisite knowledge</u> in order to crack the LFSR: Oscar, as always, must know the complete ciphertext string. Furthermore, he must know the degree <em>m</em> of the LFSR, i.e. the number of flip-flops in the register. This is reasonable knowledge to assume in real life, since the specifications of most cryptographic algorithms (including the m value) are made freely available under Kerckhoffs' Principle (Rule 3). Most damningly, he must also know the first few plaintext characters: x<sub>0</sub>, ..., x<sub>2m - 1</sub>. Much in the same fashion as how the Linear Congruential Generator was cracked (see Rule 29), it can be assumed that the header information of the document supplies this plaintext, and thus it is still realistic for that amount of plaintext to be known to the attacker.<br><br>
          
          Given this knowledge, Oscar simply has to follow a 3-step process in order to recover the entire key:<br><br><br>
          
          
          <p style="font-size:118%;"><u><strong>Step 1</strong></u>: </p>
          Utilizing the definition of the encryption function of a stream cipher (Rule 25), the keystream at position i can be isolated:<br><br>
          
          i ∈ <strong>ℤ</strong><sub>2m</sub><br><br>
          <strong>S<sub>i</sub> ≡ (x<sub>i</sub> + y<sub>i</sub>) mod 2</strong>.<br><br>
          
          Since Oscar knows the first 2m bits of both the plaintext and ciphertext, he is able to recover the first 2m keystream bits of the LFSR, which is still <u>not enough:</u> the maximum possible period is 2<sup>m</sup> - 1, so there remain a considerable number of keystream bits that need to be recovered before a complete decryption of the plaintext is possible.<br><br><br>
          
          
          <p style="font-size:118%;"><u><strong>Step 2</strong></u>: </p>
          In order to discover the remaining bits, the feedback coefficients of the multiplier functions must be discovered. This is done using the generalized summation equation of the LFSR (Rule 33). Expanding out the summation will produce the following equation:<br><br>
          
          <strong>S<sub>m</sub> ≡ (S<sub>m-1</sub> × P<sub>m-1</sub> + ... + S<sub>0</sub> × P<sub>0</sub>) mod 2</strong><br><br>
          
          <!--babytalk, but whatever-->
          Since Oscar conveniently knows the m value, the only unknowns in this equation are every single feedback coefficient. Thus, there are a total of m unknowns that need to be solved for. In order to solve for m unknowns, a system-of-equations type problem, with m equations, must be created:<br><br>
          
          <strong>S<sub>m</sub> ≡ (S<sub>m-1</sub> × P<sub>m-1</sub> + ... + S<sub>0</sub> × P<sub>0</sub>) mod 2</strong><br><br>
          
          <strong>S<sub>m+1</sub> ≡ (S<sub>m</sub> × P<sub>m-1</sub> + ... + S<sub>1</sub> × P<sub>0</sub>) mod 2</strong><br><br>
          .<br>
          .<br>
          .<Br><br>
          
          <strong>S<sub>2m-1</sub> ≡ (S<sub>2m-2</sub> × P<sub>m-1</sub> + ... + S<sub>m-1</sub> × P<sub>0</sub>) mod 2</strong><br><br>
          
          As was done for Linear Congruential Generators, each unknown can easily be solved for by Gaussian Elimination ([[[[[) or Matrix Inversion ([[[[[[[[).<br><br><br>
          
          
          
          <p style="font-size:118%;"><u><strong>Step 3</strong></u>: </p>
          Now that Oscar knows all of the Feedback Coefficients, he can build the LFSR himself.<br><br>
          
          He can determine the initial state using the output bits that are already known (using the Diagonal Rule, see Rule 31), and from there he will be able to compute the full keystream, S<sub>2m+1</sub> and beyond.<br><br>
          
          With the keystream, Oscar will now, of course, be able to recover the full plaintext:<br><br>
          
          <strong>x<sub>i</sub> ≡ (y<sub>i</sub> + s<sub>i</sub>) mod 2</strong>
      	  </div><br><br>
	  
	  
	  
  	  
  	    </article>
  	    <header class="articleHeader"><hr>
  	      <h3><span class="mw-headline" id="AltSecureStream">III.V Alternate Secure Stream Ciphers.</span></h3>
  	    </header>
  	    <article>
  	    
  	  
      	  <strong><font color="blue"><a href="#ModernCiphers"><span class="mw-headline" id="ModernCiphers">#</span></a> The Development of Modern Stream Ciphers:</font></strong><br><br>
      
          During the 1990s, stream ciphers were a center of attention for many cryptanalysts, who ruthlessly revealed vulnerabilites and weaknesses that opened particular popular ciphers of the time - this would fuel the predominance of block ciphers in modern cryptographic communications. <br><br>As a result, the eSTREAM project was established in 2004 by the "European Network of Excellence in Cryptology" (an E.U. front), which called for the development (and expert selection) of stream ciphers.<br><br> By 2008, several new, highly secure stream ciphers were developed, divided into two main categories/profiles:<br><br>
          
          <strong>1.</strong> Stream ciphers designed for implementation in software with high-volume data transfer requirements. Examples: Salsa20 (see Rule 40) & ChaCha (see Rule [[[[).
          <br><br>
          
          <strong>2.</strong> Stream ciphers designed for hardware implementation, with low power consumption, storage capabilities, and gate counts. Example: Trivium (see Rule [[[[).
          <br><br><br>
  
  	  
      	  <strong><a href="#ARXORDef"><span class="mw-headline" id="ARXORDef">#</span></a> <font color="#006400">Add-Rotate-XOR (ARX) Ciphers</font></strong>: An algorithm in a cryptosystem that only uses additions, rotations, and XOR operations to generate its keystream.
          <br><br><br>
      	  
      	  <strong><a href="#NonceDef"><span class="mw-headline" id="NonceDef">#</span></a> <font color="#006400">"Nonce"</font></strong>: A number used only once.
          <br><br><br>
  	  
  	  
  	      <div class="rule"><strong>
              <a href="#Rule"><span class="hash">#</span></a> 
              <font color="red">C. Rule <span class="rule-number"></span>.</font>
          </strong> <strong>Salsa20:</strong><br><br>

          <strong><u>Mathematical Definition</u></strong>:<br><br>
          
          [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
          
          
          <strong><u>Explanation:</u></strong><br><br>
          
          
          
          
          <strong>"Salsa20"</strong> is a family of profile-1 stream ciphers, developed in 2005. The PRNG utilizes a 32-bit ARX framework, with additional layers of security added through increased 'rounds' of encryption: the base cipher (Salsa20/20) uses 20 ciphers, while reduced-round, faster varients use 12 rounds (Salsa20/12) and 8 rounds (Salsa20/8), respectively.<br><br>
          
          Salsa20/20 (hereafter referred to as "Salsa20") supports key-lengths of either 128 or 256 bits, though 256 is recommended. 
          
          [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
    
          </div><br><br>
	  
	  
  	      <div class="rule"><strong>
              <a href="#Rule"><span class="hash">#</span></a> 
              <font color="red">C. Rule <span class="rule-number"></span>.</font>
          </strong> [[[[[Reserved for Future Usage. If additional rules are needed, then the <a href="/information/color.html#WoO">WoO system</a> will be used.[[[[[
  	  
        	  [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20, ChaCha, and Trivium"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
        	  
        	  </div><br><br>
  	  
  	  
  	      <div class="rule"><strong>
              <a href="#Rule"><span class="hash">#</span></a> 
              <font color="red">C. Rule <span class="rule-number"></span>.</font>
          </strong> [[[[[Reserved for Future Usage. If additional rules are needed, then the <a href="/information/color.html#WoO">WoO system</a> will be used.[[[[[
  	  
      	  [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20, ChaCha, and Trivium"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
      	    </div><br><br>
  	    
  	    
  	      <div class="rule"><strong>
              <a href="#Rule"><span class="hash">#</span></a> 
              <font color="red">C. Rule <span class="rule-number"></span>.</font>
          </strong> [[[[[Reserved for Future Usage. If additional rules are needed, then the <a href="/information/color.html#WoO">WoO system</a> will be used.[[[[[
  	  
      	  [[[[[To be completed at a later date. I have determined this topic: <strong>"Salsa20, ChaCha, and Trivium"</strong>, to be non-essential to the learning and understanding of the major fundamentals of <strong>Cryptography</strong>, and so it has been placed in the <a href="/_other/register.txt">low-priority learning register</a>.[[[[[<br><br>
    	    </div><br><br>
	  
	  
	    
	    
	    <!--
	    https://i56578-swl.blogspot.com/p/polynomials.html
	    
	    
	    -->
	    


	  <!-- ┗ ┛ ┏ ┓ ┳  ┃ ━  ┳ ┻ ┣ ┫  ╋  ← → ↑ ↓ ↖ ↗ ↘ ↙   &lt; is <, &gt; is >, &amp; is &  ½  ₁₂  ∞  ∪ · ∘  ±  ×  π  ∆  μ ⁻  θ  α ω  τ ° ≠ ≈  ≤,  ≥   ÷, the roof is &#x302; -->
	    <!-- alt-0178 for superscript 2, 0179 for 3. Others are further up. &nbsp; &thinsp; &hairsp;-->
	    <!--<span class="vecteur"><strong>r</strong></span> VECTOR-->
	    <!--<div title="me inm">bango</div> secret text for hovering over-->
	    <!--<span style="white-space: nowrap">&radic;<span style="text-decoration:overline;">x</span></span>--><!--cube is &#8731;, 4th is &#8732;,  -->
	    <!--<span style="border-right: 1px black solid; border-radius: 0px 0px 10px 0px">divisor </span><span style="border-top: 1px black solid; ">&thinsp;dividend&thinsp;</span>-->
	    
	    
	    
	    <!--
	      <div class="rule"><strong>
            <a href="#Rule"><span class="hash">#</span></a> 
            <font color="red">C. Rule <span class="rule-number"></span>.</font>
        </strong> </div><br><br>
	  -->
	    
	  </article>
	  
	  </div>
	</div>
	
	<div class="General links">
		links
		<hr>
		Programming<br>
		<a href="https://www.youtube.com/watch?v=8jLOx1hD3_o">Short C++ Tutorial</a><br>
		<a href="https://codeforces.com/blog/entry/125639">Code</a><a href="https://www.youtube.com/@tmwilliamlin168/videos">forces</a><br>
		<a href="https://www.youtube.com/playlist?list=PLGs0VKk2DiYw-L-RibttcvK-WBZm8WLEP">Arduino Tutorial</a><br>
		<a href="https://www.youtube.com/playlist?list=PLGs0VKk2DiYz8js1SJog21cDhkBqyAhC5">MicroPython</a><br>
		<a href="https://matplotlib.org/cheatsheets/">2D Python Plots</a><br><br>
		MIDI<br>
		<a href="https://www.anvilstudio.com/">Anvil Studio</a><br>
		<a href="https://meme.institute/gxscc/">GXSCC</a><br><br>
		Physics<br>
		<a href="https://www.feynmanlectures.caltech.edu/I_toc.html">Feynman Lectures</a><br>
		<a href="https://www.youtube.com/@FlippingPhysics/playlists">Physics Intro.</a><br>
		<hr>
		<a href="https://ocw.mit.edu/" class="imglink"><img src="/_other/ocw_logo_orange.202255b67af1a72a1f52.png" width=90%></a>
		<a href="https://www.eff.org/issues/innovation" class="imglink"><img src="/_other/eff.png" width=90%></a>
		<a href="https://archive.org/donate" class="imglink"><img src="/_other/internetarchive.gif" width=60%></a>
	</div>
      
</div>
      <footer class="site">
        <br>
        <strong><a href="/cryptography/symmetry.html">Symmetric Cryptography</a></strong><br>
        <article><strong>Pt. 1: Intro & Stream Ciphers</strong> → <strong><a href="/cryptography/symmetricFull2.html">Pt. 2: Block Ciphers</a></strong></article>
        <br>
        <article><strong><a href="/cryptography/symmetric/intro.html">Introductions</a></strong> → <strong><a href="/cryptography/symmetric/historical.html">Historical Ciphers & Modular Arithmetic</a></strong> → <strong><a href="/cryptography/symmetric/stream.html">Stream Ciphers</a></strong> → <strong><a href="/cryptography/symmetric/block.html">Block Ciphers: Intro & DES</a></strong><br> → <strong><a href="/cryptography/symmetric/block2.html">Block Ciphers: AES</a></strong><!-- → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong> → <strong><a href=""></a></strong>--></article>
      	<br>
      	<hr>
      	<span class="tiny">Last Change: August 3 2025</span><br>
      	<span class="tiny">Jonathan Lacabe 2025</span><br>
      	<span class="tiny"><a href="mailto:jdlacabe@gmail.com">jdlacabe@gmail.com</a></span><br>
      	<img src="/_other/with_love%20(1).gif" width=9%>
      </footer>
      </div>
   </body>
<!--Someday we'll figure out how to program computers deterministically. But, alas.-->
</html>
